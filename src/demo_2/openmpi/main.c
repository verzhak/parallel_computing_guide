
/*

Многопоточное моделирование гамма - распределения с помощью датчика псевдослучайных чисел, распределенных равномерно

Сборка программы:

	mpicc -Wall -lm -lrt main.c -o demo

	Здесь:

		-Wall - ключ, предписывающий компилятору выводить предупреждения о всех потенциальных ошибках в программе;
		-lm - ключ, подключающий к программе математическую библиотеку из состава стандартной библиотеки языка программирования C;
		-lrt - ключ, подключающий к программе библиотеку получения информации о времени;
		main.c - файл с исходным кодом программы;
		-o demo - указание имени результирующего исполняемого файла.

Запуск программы:

	mpirun -mca orte_rsh_agent ssh -n 4 -H localhost,192.168.0.177 -x PATH="/bin:/usr/bin:/sbin:/usr/sbin:/usr/local/bin:/usr/local/sbin:`pwd`:/home/amv/trash/" demo

	Здесь:

		-mca orte_rsh_agent ssh	- предписание использовать протокол SSH для пересылки сообщений между вычислительными потоками;
		-n 4 - предписание запустить четыре вычислительных потока;
		-H localhost,192.168.0.177 - перечисление адресов (символьных и IP-адресов) вычислительных систем, в которых будут запущены вычислительные потоки;
		-x PATH="..." - явное указание значения переменной окружения PATH (с помощью команды pwd происходит подстановка в перечисление каталогов абсолютного пути до текущего каталога).

*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <time.h>

#include <mpi.h>

/* Макрос вызова функций стандарта MPI. Данный макрос проверяет успешность завершения вызываемой функции - в случае неудачи макрос выводит соответствующее сообщение в стандартный поток ошибок и завершает выполнение вычислительного потока. */
#define call(func) \
{\
	if((func) != MPI_SUCCESS) \
	{\
		fprintf(stderr, "[Ошибка] Строка %u, Файл %s\n", __LINE__, __FILE__);\
		return -1;\
	}\
}

/* Моделирование показательного распределения с помощью датчика псевдослучайных чисел, равномерно распределенных на диапазоне [0; 1) */ 
double exp_distrib(double beta)
{
	return - log(drand48()) * beta;
}

/* Главная функция программы */
int main(int argc, char * argv[])
{
	int t_ind, t_num, t_num_1;
	unsigned u, v, num, alpha, N;
	double t_x, P, * m, * d, * x, beta, r_m, r_d;
	struct timespec ts_before, ts_after;
	MPI_Status status;

	/* Инициализация вычислительного потока */
	call(MPI_Init(& argc, & argv));

	/* Определение номера вычислительного потока */
	call(MPI_Comm_rank(MPI_COMM_WORLD, & t_ind));

	/* Инициализация датчика псевдослучайных чисел */
	srand48(lrand48());

	if(! t_ind)
	{
		/* Главный вычислительный поток (поток с номером 0) */

		/* Определение времени начала расчетов */
		clock_gettime(CLOCK_REALTIME, & ts_before);

		/* Определение количества вычислительных потоков */
		call(MPI_Comm_size(MPI_COMM_WORLD, & t_num));

		/* Инициализация некоторых переменных (переменные alpha и beta суть есть параметры гамма - распределения) */
		alpha = 5;
		beta = 10;
		N = 10000000;
		t_num_1 = t_num - 1;
		m = calloc(t_num, sizeof(double));
		d = calloc(t_num, sizeof(double));
	}

	/* Широковещательная рассылка параметров alpha и beta гамма - распределения */
	call(MPI_Bcast(& alpha, 1, MPI_UNSIGNED, 0, MPI_COMM_WORLD));
	call(MPI_Bcast(& beta, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD));

#define NUM_TAG 1

	if(t_ind)
	{
		/* Вычислительные потоки с номерами, большими нуля */

		/* Получение вычислительным потоком сообщения с тегом, равным значению константы компилятора NUM_TAG - получение вычислительным потоком сообщения, содержащего количество реализаций псевдослучайной величины с гамма - распределением, генерируемых данным вычислительным потоком */
		call(MPI_Recv(& num, 1, MPI_UNSIGNED, 0, NUM_TAG, MPI_COMM_WORLD, & status));

		x = calloc(num, sizeof(double));

		for(u = 0, r_m = 0; u < num; u++)
		{
			/* Генерация очередной реализации псевдослучайной величины */
			for(v = 0, P = 0; v < alpha; v++)
				P += exp_distrib(beta);

			/* Подсчет суммы реализаций псевдослучайной величины */
			r_m += (x[u] = P);
		}
	}
	else
		/* Главный вычислительный поток (поток с номером 0) */

		for(u = 1, num = N / t_num_1; u < t_num; u++)
		{
			/* Вычисление и отправление каждому вычислительному потоку количества генерируемых им реализаций псевдослучайной величины */

			if(u == t_num_1)
				num = N - (t_num - 2) * num;

			call(MPI_Send(& num, 1, MPI_UNSIGNED, u, NUM_TAG, MPI_COMM_WORLD));
		}

	/* Сбор сумм сгенерированных вычислительными потоками реализаций псевдослучайной величины */
	call(MPI_Gather(& r_m, 1, MPI_DOUBLE, m, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD));

	if(! t_ind)
	{
		/* Главный вычислительный поток (поток с номером 0) рассчитывает эмпирическое математическое ожидание псевдослучайной величины */

		for(u = 1, r_m = 0; u < t_num; u++)
			r_m += m[u];

		r_m /= (double) N;
	}

	/* Широковещательная рассылка эмпирического математического ожидания */
	call(MPI_Bcast(& r_m, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD));

	if(t_ind)
		/* Вычислительные потоки с номерами, большими нуля, рассчитывают суммы квадратов центрированных реализаций псевдослучайной величины */
		for(u = 0, r_d = 0; u < num; u++)
		{
			t_x = x[u] - r_m;
			r_d += t_x * t_x;
		}

	/* Сбор сумм квадратов центрированных реализаций псевдослучайной величины */
	call(MPI_Gather(& r_d, 1, MPI_DOUBLE, d, 1, MPI_DOUBLE, 0, MPI_COMM_WORLD));

	if(t_ind)
		free(x);
	else
	{
		/* Главный вычислительный поток (поток с номером 0) */
		
		/* Расчет эмпирической дисперсии */
		for(u = 1, r_d = 0; u < t_num; u++)
			r_d += d[u];

		r_d /= (double) N;

		free(m);
		free(d);

		/* Определение времени окончания расчетов */
		clock_gettime(CLOCK_REALTIME, & ts_after);
		
		/* Вывод результатов выполненных расчетов */
		printf("\nМатематическое ожидание:\n\n\tЭмпирическое = %lf\n\tТеоретическое = %lf\n\nДисперсия:\n\n\tЭмпирическая = %lf\n\tТеоретическая = %lf\n\nРасчет выполнили %d поток(а; ов) за %lf секунд(ы)\n\n", r_m, alpha * beta, r_d, alpha * beta * beta, t_num, ts_after.tv_sec - ts_before.tv_sec + 1 + (ts_after.tv_nsec - ts_before.tv_nsec) / 1000000000.0);
	}

	/* Корректное завершение вычислительного потока */
	call(MPI_Finalize());

	return 0;
}

