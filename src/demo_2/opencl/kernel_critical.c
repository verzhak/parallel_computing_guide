
/* Исходный код ядра (главной функции) вычислительных потоков */

/* Активация расширений стандарта OpenCL, позволяющих использовать атомарные операции */
#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable
#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable

kernel void MD(__global const float * X, unsigned N, __global float * res)
{
	/*

	Макрос - начало критической секции:
	
	1) Вычислительный поток с индексом 0 сбрасывает флаг критической секции;
	2) Вычислительные потоки синхронизируются;
	3) Каждый из вычислительных потоков пытается установить флаг.

	Как только вычислительному потоку удается установить флаг (функция atomic_xchg() возвращает ноль), вычислительный поток считается вошедшим в критическую секцию.
	
	*/
#define CRITICAL_BEGIN \
{\
	if(! t_ind)\
		flag = 0;\
\
	barrier(0);\
\
	while(atomic_xchg(& flag, 1));\
}

	/*
	
	Макрос - завершение критической секции:

	1) Вычислительный поток сбрасывает флаг, выходя, таким образом, из критической секции;
	2) Вычислительные потоки синхронизируются.

	*/
#define CRITICAL_END \
{\
	atomic_xchg(& flag, 0);\
\
	barrier(0);\
}

	/* Определение количества вычислительных потоков (все они должны находится в одной группе потоков), определение номера вычислительного потока */
	size_t t_num = get_global_size(0), t_ind = get_global_id(0);
	unsigned u, step = N / t_num;

	/* Определение границ подмассива массива X - массив X делится на несколько не пересекающихся смежных друг с другом подмассивов, каждый из которых будет обработан отдельным вычислительным потоком */
	unsigned t_from = t_ind * step;
	unsigned t_to = (t_ind == t_num - 1) ? N : t_from + step;

	float d, t_M = 0, t_D = 0;
	__local float l_M, l_D;

	/* Флаг критической секции */
	__local int flag;

	if(! t_ind)
		l_M = l_D = 0;

	/* Расчет суммы элементов подмассива */
	for(u = t_from; u < t_to; u++)
		t_M += X[u];

	CRITICAL_BEGIN;

	/* Постепенное накопление эмпирического математического ожидания */
	l_M += t_M / N;

	CRITICAL_END;

	/* Расчет суммы центрированных элементов подмассива */
	for(u = t_from, t_M = l_M; u < t_to; u++)
	{
		d = (X[u] - t_M);
		t_D += d * d;
	}

	CRITICAL_BEGIN;

	/* Постепенное накопление эмпирической дисперсии */
	l_D += t_D / N;

	CRITICAL_END;

	/* Нулевой вычислительный поток возвращает в управляющий программный модуль результаты вычислений */
	if(! t_ind)
	{
		res[0] = l_M;
		res[1] = l_D;
	}
}

