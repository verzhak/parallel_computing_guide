
\mysubsubsection{Введение}

	TODO

\mysubsubsection{Стандарт OpenCL}

\myparagraph{Введение}

Стандарт OpenCL предназначен для организации параллельных и распределенных вычислений на различных типах процессоров, к которым относятся, прежде всего, графические процессоры (GPU) и центральные процессоры (CPU).

Стандарт OpenCL создан компанией Apple, утвержден в 2008-м году и поддерживается промышленным консорциумом Khronos Group \cite{khronos}. Стандарт OpenCL является открытым - документация к нему находится в открытом доступе на сайте Khronos Group \cite{opencl}.

Стандарт OpenCL реализуется ключевыми производителями графических процессоров (NVIDIA, AMD и Intel) в соответствующих SDK (TODO расшифровка), что позволяет разработчику создавать переносимые между различными аппаратными платформами приложения, использующие GPU и CPU для организации параллельных и распределенных вычислений. Существуют следующие бесплатные реализации стандарта OpenCL:

\begin{itemize}

	\item Реализация от компании NVIDIA.

		Данная реализация поддерживает только GPU, выпущенные компанией NVIDIA и поддерживающие технологию GPGPU;

	\item Реализация от компании AMD - входит в состав ATI FireStream.

		Данная реализация поддерживает CPU архитектур IA-32 и x86-64 и GPU, выпущенные компанией AMD (ATI) и поддерживающие технологию GPGPU;

	\item Реализация от компании Intel - Intel OpenCL SDK.

		Данная реализация поддерживает только CPU архитектур IA-32 и x86-64, поддерживающие Intel Streaming SIMD Extensions (SSE) версии 4.1 и выше.

\end{itemize}

Программа, написанная с использованием стандарта OpenCL, состоит из программных модулей:

\begin{itemize}

	\item Программный модуль, выполняемый на целевом вычислительном устройстве (на целевом процессоре).
	
		Данный программный модуль состоит из набора подпрограмм, реализующих ядра (главные функции) вычислительных потоков, и набора сопроводительных подпрограмм.

		Параллельные и распределенные вычисления, реализуемые с помощью стандарта OpenCL, заключаются в одновременном выполнении одного и того же ядра несколькими вычислительными потоками.

		Исходный код программного модуля, выполняемого на целевом вычислительном устройстве, должен быть написан на диалекте языка программирования C, описанного в стандарте OpenCL. Означенный диалект частично совместим со стандартом C99 - так, например, диалект языка C из стандарта OpenCL не содержит реализацию стандартной библиотеки языка (вместо которой в стандарте OpenCL описана собственная библиотека функций);

	\item Программный модуль, выполняемый на управляющем устройстве.

		Данный программный модуль контролирует работу программного модуля, выполняемого на целевом вычислительном устройстве - компилирует исходный код означенного программного модуля, определяет фактические параметры ядер вычислительных потоков, запускает ядра вычислительных потоков на выполнение на целевом вычислительном устройстве, анализирует результаты выполнения ядер вычислительных потоков.

		Стандарт OpenCL описывает функционал, с помощью которого управляющий программный модуль взаимодействует с программным модулем, выполняемом на целевом вычислительном устройстве.

\end{itemize}

Организация выполнения вычислительных потоков на целевом вычислительном устройстве имеет иерархическую структуру, принципиальная схема которой приведена на рисунке \ref{image:opencl:struct}.

\begin{landscape}
~
\vfill
\mimage{opencl:struct}{opencl-struct.eps}{Схема организации выполнения вычислительных потоков на целевом вычислительном устройстве, реализуемая стандартом OpenCL}{width=\linewidth}
\vfill
~
\end{landscape}

В основе организации выполнения вычислительных потоков лежит управляющий программный модуль, определяющий количество выполняемых вычислительных потоков, значения параметров их ядер, запускающий на выполнения ядра вычислительных потоков и анализирующий результаты выполнения ядер вычислительных потоков.

Вычислительные потоки, называемые также рабочими единицами ((англ.) work-item), объединяются в группы потоков (рабочие группы, (англ.) work-group). На вычислительном устройстве может одновременно выполняться несколько групп потоков, при этом вычислительное устройство самостоятельно (на аппаратном или программном, но скрытом от разработчика, уровнях) распределяет вычислительные ресурсы между группами вычислительных потоков и вычислительными потоками в составе означенных групп. Для каждого вычислительного устройства существуют собственные ограничения на количество групп вычислительных потоков и количество вычислительных потоков в каждой из групп.

Все вычислительные потоки разделяют глобальную, доступную им на чтение и запись, и константную, доступную им только на чтение, память. Потоки, входящие в одну группу, разделяют локальную память группы, доступную им на чтение и запись. Каждый из вычислительных потоков обладает также своей собственной, доступной только ему, локальной памятью.

Доступ к локальной памяти потока занимает меньше всего времени, однако объем локальная память не превышает нескольких килобайт. Второй по скорости доступа и большей по объему памятью является локальная память группы вычислительных потоков. Наконец, самыми объемными, но в то же время самыми медленными, являются глобальная и константная память.

Доступ к глобальной и константной памяти имеет также управляющий программный модуль, что позволяет организовать канал передачи данных между главным программным модулем и ядрами вычислительных потоков.

Перез запуском вычислительных потоков управляющий программный модуль определяет размерность пространства вычислительных потоков (доступны одно-, двух- и трехмерные пространства) и размер пространства по каждой из размерностей. Каждый вычислительный поток, таким образом, идентифицируется своим собственным вектором целочисленных неотрицательных координат. В простейшем случае - размерность пространства равна единице - вектора координат вычислительных потоков сводятся к нумерации вычислительных потоков, начиная с нуля.

\myparagraph{Программный модуль, выполняемый на целевом вычислительном устройстве}

	\mysubparagraph{Ядра вычислительных потоков и сопроводительный функционал}

		Исходный код данного программного модуля суть есть совокупность описаний функций следующих типов:

		\begin{itemize}

			\item Ядра вычислительных потоков.

				Прототип ядра вычислительного потока должно предворять ключевое слово \verb|kernel| или ключевое слово \verb|__kernel|.

				Ядро вычислительного потока не должно ничего возвращать (типом его возвращаемого значения должен быть void);

			\item Прочие функции.

				Описываются как обычные функции языка программирования C.

		\end{itemize}

	\mysubparagraph{Описание переменных. Квалификаторы памяти}

		Для явного указания типа памяти, в которой должна быть размещена объявляемая переменная, при объявлении переменной перед названием ее типа указывается один из следующих квалификаторов памяти:

		\begin{itemize}

			\item \verb|global| или \verb|__global| - переменная будет расположена в глобальной памяти;
			\item \verb|constant| или \verb|__constant| - переменная будет расположена в константной памяти.

			Ключевое слово \verb|const| языка программирования C также доступно и означает, что значение объекта программы невозможно изменить;

			\item \verb|local| или \verb|__local| - переменная будет расположена в локальной памяти группы вычислительных потоков;
			\item \verb|private| или \verb|__private| - переменная будет расположена в локальной памяти вычислительного потока.

		\end{itemize}

		Переменная без квалификатора располагается в локальной памяти вычислительного потока.

		При задании списка параметров ядер вычислительных потоков необходимо учитывать следующие особенности:

		\begin{itemize}

			\item Указатель на область памяти должен быть размещен в глобальной или константной памяти, поскольку области памяти, на которую он указывает, создана и инициализирована управляющим программным модулем, который имеет доступ только к глобальной и константной памяти;

			\item Прочие параметры функции могут быть расположены в локальной памяти вычислительного потока, так как их установ главным потоком происходит с использованием определенного функционала, непосредствено не имеющего доступ к локальной памяти вычислительного потока;

		\end{itemize}

		Допускается указывать только один квалификатор памяти.

	\mysubparagraph{Позиционирование вычислительного потока}

		Позиционирование вычислительного потока в пространстве вычислительных потоков осуществляется им путем получения каждой из своих координат. Для получения своей координаты по какому-либо измерению вычислительный поток должен использовать функцию {\bf get\_global\_id()}, прототип которой приведен в листинге \ref{listing:opencl:ggi}.

\mylistingbegin{opencl:ggi}{Функция get\_global\_id()}
\begin{lstlisting}

size_t get_global_id(unsigned dim);

\end{lstlisting}
\mylistingend

		Определить размер пространства вычислительных потоков по некоторой размерности вычислительный поток может с помощью функции {\bf get\_global\_size()}, прототип которой приведен в листинге \ref{listing:opencl:gws}.

\mylistingbegin{opencl:gws}{Функция get\_global\_size()}
\begin{lstlisting}

size_t get_global_size(unsigned dim);

\end{lstlisting}
\mylistingend

		Единственными параметрами функций get\_global\_id() и get\_global\_size() являются номера интересующего вычислительный поток измерения (нумерация вычислительных потоков и нумерация измерений начинаются с нуля).

		Определить размерность пространства вычислительных потоков вычислительный поток может с помощью функции {\bf get\_work\_dim()}, прототип которой приведен в листинге \ref{listing:opencl:gwd}.

\mylistingbegin{opencl:gwd}{Функция get\_work\_dim()}
\begin{lstlisting}

unsigned get_work_dim();

\end{lstlisting}
\mylistingend

	\mysubparagraph{Синхронизация вычислительных потоков. Критические секции кода}

		Для синхронизации своего выполнения вычислительные потоки, составляющие группу вычислительных потоков, могут использовать функцию {\bf barrier()}, прототип которой приведен в листинге \ref{listing:opencl:barrier}.

\mylistingbegin{opencl:barrier}{Функция barrier()}
\begin{lstlisting}

void barrier(0);

\end{lstlisting}
\mylistingend

		Функция barrier() блокирует выполнение вычислительного потока до тех пор, пока все остальные вычислительные потоки из группы данного вычислительного потока не выполнят функцию barrier().

		Стандарт OpenCL не содержит функционала обрамления критических секций кода, поэтому задача разработки такового функционала целиком ложится на плечи разработчика. Один из способов организации критической секции для вычислительных потоков, составляющих одну группу, приведен в листинге \ref{listing:opencl:critical}.

\mylistingbegin{opencl:critical}{Организация критической секции для группы вычислительных потоков}
\begin{lstlisting}

__local int flag;

if(! get_global_id())
	flag = 0;

barrier(0);

while(atomic_xchg(& flag, 1));

CRITICAL_SECTION;

atomic_xchg(& flag, 0);

barrier(0);

\end{lstlisting}
\mylistingend

	Критическая секция, прототип которой приведен в листинге \ref{listing:opencl:critical}, работает по следующему алгоритму:

	\begin{enumerate}

		\item Группа вычислительных потоков описывает целочисленную переменную flag, расположенную в локальной памяти группы. Целочисленная переменная flag будет использоваться как флаг критической секции - признаком свободной критической секции будет значение 0 переменной flag (флаг сброшен), признаком занятой критической секции - ненулевое значение переменной flag (флаг установлен);
		\item Нулевой вычислительный поток сбрасывает флаг критической секции;
		\item Вычислительные потоки синхронизируются;
		\item Каждый вычислительный поток пытается установить флаг критической секции - пытается занять критическую секцию.

			Функция atomic\_xchg() устанавливает значение переменной, указатель на которую передан ей в первом параметре, в значение, указанное во втором параметре, возвращая при этом старое значение целевой переменной. Функция atomic\_xchg() гарантирует атомарность выполняемой операции - то есть в некоторый момент времени только один вычислительный поток может выполнять данную операцию, все прочие вычислительные потоки будут ожидать данный.

			Таким образом, вычислительный поток только тогда продолжит свое выполнение, когда ему удастся изменить значение переменной flag с нуля на единицу - то есть, когда ему удастся установить флаг, бывший в сброшенном состоянии;

		\item Вычислительный поток выполняет критическую секцию (CRITICAL\_SECTION);
		\item Вычислительный поток сбрасывает флаг;
		\item Вычислительные потоки синхронизируются.

	\end{enumerate}

	Для использования атомарных операцийв исходный код программного модуля, выполняющегося на вычислительном устройстве, необходимо добавить вызов прагмы OPENCL EXTENSION со специальными параметрами активации расширений стандарта OpenCL, ответственных за реализацию атомарных операций. Вызов прагмы добавляется вне функций. Синтаксис вызова прагмы приведен в листинге \ref{listing:opencl:critical:act}.

\mylistingbegin{opencl:critical:act}{Прагма OPENCL EXTENSION}
\begin{lstlisting}

#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable
#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable

\end{lstlisting}
\mylistingend

	\mysubparagraph{Библиотека функций}

		TODO

	\mysubparagraph{Некоторые особенности диалекта языка программирования C, используемого в стандарте OpenCL}

		Тип данных double реализуется как расширение к диалекту и поддерживается не всеми вычислительными устройствами. В целях повышения переносимости программ между аппаратными платформами для операций над вещественными числами рекомендуется использовать тип данных float.

\myparagraph{Программный модуль, выполняемый на управляющем вычислительном устройстве}

	TODO

