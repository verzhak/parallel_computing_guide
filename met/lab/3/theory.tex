
\mysubsubsection{Введение}

Одной из современных тенденций в организации параллельных и распределенных вычислений стало распределение вычислений среди нескольких графических процессоров (GPU).

Первой компанией, представившей рынку промышленный стандарт произвольных вычислений на графическом процессоре (GPGPU), стала компания NVIDIA, выпустившая в 2007-м году комплект разработчика (SDK) CUDA для своих графических процессоров серий GeForce, Tesla и Quadro.

Ответом компании ATI (ныне входящей в состав компании AMD) на выпуск SDK CUDA стал выход SDK Close to Metal и, позже, SDK FireStream, пришедшего на смену SDK Close to Metal.

Каждый из перечисленных SDK реализует свой собственный интерфейс работы с графическими процессорами, поддерживаемый только теми графическими процессорами, которые выпускает компания - разработчик SDK. Стандартом, который позволил бы разработчикам создавать переносимые многопоточные приложения, использующие для организации параллельных и распределенных вычислений несколько GPU, стал стандарт OpenCL, созданный компанией Apple и поддерживаемый промышленным консорциумом Khronos Group.

\mysubsubsection{Стандарт OpenCL}

\myparagraph{Введение}

Стандарт OpenCL ((англ.) Open Computing Language - открытый язык вычислений) предназначен для организации параллельных и распределенных вычислений на различных типах процессоров, к которым относятся, прежде всего, графические процессоры (GPU) и центральные процессоры (CPU).

Стандарт OpenCL выпущен компанией Apple в 2008-м году и в настоящее время поддерживается промышленным консорциумом Khronos Group \cite{khronos}. Стандарт OpenCL является открытым - документация к нему находится в открытом доступе на сайте Khronos Group \cite{opencl}.

Стандарт OpenCL реализуется ключевыми производителями графических процессоров (NVIDIA, AMD и Intel) в соответствующих SDK, что позволяет разработчику создавать переносимые между различными аппаратными платформами приложения, использующие GPU и CPU для организации параллельных и распределенных вычислений. Существуют следующие бесплатные реализации стандарта OpenCL:

\begin{itemize}

	\item Реализация от компании NVIDIA - входит в состав SDK CUDA.

		Данная реализация поддерживает только GPU, выпущенные компанией NVIDIA и поддерживающие технологию GPGPU;

	\item Реализация от компании AMD - входит в состав SDK FireStream.

		Данная реализация поддерживает CPU архитектур IA-32 и x86-64 и GPU, выпущенные компанией AMD (ATI) и поддерживающие технологию GPGPU;

	\item Реализация от компании Intel - Intel OpenCL SDK.

		Данная реализация поддерживает только CPU архитектур IA-32 и x86-64, поддерживающих, в свою очередь, набор инструкций Intel Streaming SIMD Extensions (SSE) версии 4.1 и выше.

\end{itemize}

Программа, написанная с использованием стандарта OpenCL, состоит из программных модулей:

\begin{itemize}

	\item Программный модуль, выполняемый на целевом вычислительном устройстве (на целевом процессоре - GPU или CPU).
	
		Данный программный модуль состоит из набора подпрограмм - ядер (главных функций) вычислительных потоков, и набора дополнительных к ядрам подпрограмм.

		Параллельные и распределенные вычисления, реализуемые с помощью стандарта OpenCL, заключаются в одновременном выполнении одного и того же ядра несколькими вычислительными потоками.

		Исходный код программного модуля, выполняемого на целевом вычислительном устройстве, должен быть написан на специальном диалекте языка программирования C. Означенный диалект частично совместим со стандартом C99 - так, например, диалект языка C из стандарта OpenCL не содержит стандартную библиотеку языка - вместо нее в стандарте OpenCL описана собственная библиотека функций;

	\item Программный модуль, выполняемый на управляющем устройстве.

		Данный программный модуль контролирует работу программного модуля, выполняемого на целевом вычислительном устройстве - компилирует исходный код означенного программного модуля, определяет фактические параметры ядер вычислительных потоков, запускает ядра вычислительных потоков на выполнение на целевом вычислительном устройстве, анализирует результаты выполнения ядер вычислительных потоков.

		Стандарт OpenCL описывает функционал, с помощью которого управляющий программный модуль взаимодействует с программным модулем, выполняемом на целевом вычислительном устройстве.

\end{itemize}

Принципиальная схема организации параллельных и распределенных вычислений с помощью стандарта OpenCL приведена на рисунке \ref{image:opencl:struct}.

\begin{landscape}
~
\vfill
\mimage{opencl:struct}{opencl-struct.eps}{Принципиальная схема организации параллельных и распределенных вычислений с помощью стандарта OpenCL}{width=\linewidth}
\vfill
~
\end{landscape}

В основе организации параллельного выполнения вычислительных потоков лежит управляющий программный модуль, определяющий количество выполняемых вычислительных потоков, значения параметров их ядер, запускающий на выполнения ядра вычислительных потоков и анализирующий результаты выполнения ядер вычислительных потоков.

Вычислительные потоки ((англ.) work-item - рабочие единицы) объединяются в группы потоков ((англ.) work-group - рабочие группы). На вычислительном устройстве может одновременно выполняться несколько групп потоков, при этом вычислительное устройство самостоятельно (на аппаратном или программном, но скрытом от разработчика, уровнях) распределяет вычислительные ресурсы между группами вычислительных потоков и вычислительными потоками в каждой из данных групп. Для каждого вычислительного устройства существуют собственные ограничения на количество одновременно выполняемых групп вычислительных потоков и количество вычислительных потоков в каждой из них.

Все вычислительные потоки разделяют глобальную, доступную им на чтение и запись, и константную, доступную им только на чтение, память. Потоки, входящие в одну группу, разделяют локальную память группы, доступную им на чтение и запись. Каждый из вычислительных потоков обладает также своей собственной, доступной только ему, локальной памятью.

Доступ к локальной памяти потока занимает меньше всего времени, однако объем локальной памяти не превышает несколько килобайт. Второй по скорости доступа и большей по объемую по сравнению с локальной памятью потока является локальная память группы вычислительных потоков. Наконец, самыми объемными, но в то же время самыми медленными, являются глобальная и константная память.

Управляющий программный модуль имеет доступ к глобальной (на чтение и запись) и константной (на запись) памяти, что позволяет ему организовать канал передачи данных между ним и ядрами вычислительных потоков.

Перед запуском вычислительных потоков управляющий программный модуль определяет размерность пространства вычислительных потоков (доступны одно-, двух- и трехмерные пространства) и размер пространства по каждой из размерностей. Каждый вычислительный поток, таким образом, идентифицируется своим собственным вектором целочисленных неотрицательных координат. В простейшем случае - размерность пространства равна единице - вектора координат вычислительных потоков эквиваленты последовательной нумерации вычислительных потоков, начиная с нуля.

\myparagraph{Программный модуль, выполняемый на целевом вычислительном устройстве}

	\mysubparagraph{Ядра вычислительных потоков и сопроводительный к ним функционал}

		Исходный код программного модуля, выполняемого на целевом вычислительном устройстве, суть есть совокупность описаний следующих функций:

		\begin{itemize}

			\item Ядра вычислительных потоков.

				Прототип ядра вычислительного потока должно предворять ключевое слово \verb|kernel| или ключевое слово \verb|__kernel|.

				Ядро вычислительного потока не должно ничего возвращать (типом его возвращаемого значения должен быть void);

			\item Прочие функции.

				Описываются как обычные функции языка программирования C.

		\end{itemize}

	\mysubparagraph{Описание переменных. Квалификаторы памяти}

		Для явного указания типа памяти, в которой должна быть размещена объявляемая переменная, при объявлении переменной перед указанием ее типа ставится один из следующих квалификаторов памяти:

		\begin{itemize}

			\item \verb|global| или \verb|__global| - переменная будет расположена в глобальной памяти;
			\item \verb|constant| или \verb|__constant| - переменная будет расположена в константной памяти.

			Ключевое слово \verb|const| языка программирования C также доступно и означает, что значение переменной невозможно изменить;

			\item \verb|local| или \verb|__local| - переменная будет расположена в локальной памяти группы вычислительных потоков;
			\item \verb|private| или \verb|__private| - переменная будет расположена в локальной памяти вычислительного потока.

		\end{itemize}

		Переменная без квалификатора располагается в локальной памяти вычислительного потока. Допускается указывать только один квалификатор памяти.

		При задании списка параметров ядер вычислительных потоков необходимо учитывать следующие особенности:

		\begin{itemize}

			\item Параметр - указатель на область памяти должен быть размещен в глобальной или константной памяти, поскольку область памяти, на которую он указывает, создана и инициализирована управляющим программным модулем, который имеет доступ только к глобальной и константной памяти;

			\item Прочие параметры функции могут быть расположены в локальной памяти вычислительного потока, так как их установ главным потоком происходит с использованием функционала, непосредствено не имеющего доступ к локальной памяти вычислительного потока.

		\end{itemize}

	\mysubparagraph{Позиционирование вычислительного потока}

		Вычислительный поток может получить свою координату по какому-либо измерению с помощью функции {\bf get\_global\_id()}, прототип которой приведен в листинге \ref{listing:opencl:ggi}.

\mylistingbegin{opencl:ggi}{Функция get\_global\_id()}
\begin{lstlisting}

size_t get_global_id(unsigned dim);

\end{lstlisting}
\mylistingend

		Определить протяженность пространства вычислительных потоков по какому-либо измерению вычислительный поток может с помощью функции {\bf get\_global\_size()}, прототип которой приведен в листинге \ref{listing:opencl:gws}.

\mylistingbegin{opencl:gws}{Функция get\_global\_size()}
\begin{lstlisting}

size_t get_global_size(unsigned dim);

\end{lstlisting}
\mylistingend

		Единственными параметрами функций get\_global\_id() и get\_global\_size() являются номера интересующего вычислительный поток измерения (отсчет координат и нумерация измерений начинаются с нуля).

		Определить размерность пространства вычислительных потоков вычислительный поток может с помощью функции {\bf get\_work\_dim()}, прототип которой приведен в листинге \ref{listing:opencl:gwd}.

\mylistingbegin{opencl:gwd}{Функция get\_work\_dim()}
\begin{lstlisting}

unsigned get_work_dim();

\end{lstlisting}
\mylistingend

	\mysubparagraph{Синхронизация вычислительных потоков. Критические секции кода}

		Для синхронизации выполнения вычислительных потоков, составляющих группу вычислительных потоков, может быть использована функция {\bf barrier()}, прототип которой приведен в листинге \ref{listing:opencl:barrier}.

\mylistingbegin{opencl:barrier}{Функция barrier()}
\begin{lstlisting}

void barrier(0);

\end{lstlisting}
\mylistingend

		Функция barrier() блокирует выполнение вычислительного потока до тех пор, пока все остальные вычислительные потоки из группы данного вычислительного потока не выполнят функцию barrier().

		Стандарт OpenCL не содержит функционал организации критических секций кода - критические секции могут быть организованы разработчиком с помощью прочего функционала стандарта OpenCL. Один из способов организации критической секции для вычислительных потоков, входящих в одну группу, приведен в листинге \ref{listing:opencl:critical}.

\mylistingbegin{opencl:critical}{Организация критической секции для группы вычислительных потоков}
\begin{lstlisting}

__local int flag;

if(! get_global_id())
	flag = 0;

barrier(0);

while(atomic_xchg(& flag, 1));

CRITICAL_SECTION;

atomic_xchg(& flag, 0);

\end{lstlisting}
\mylistingend

	Приведенная выше реализация критической секции работает по следующему алгоритму:

	\begin{enumerate}

		\item Группа вычислительных потоков описывает целочисленную переменную flag, расположенную в локальной памяти группы. Целочисленная переменная flag будет использоваться как флаг критической секции - признаком свободной критической секции будет значение 0 переменной flag (флаг сброшен), признаком занятой критической секции - ненулевое значение переменной flag (флаг установлен);
		\item Нулевой вычислительный поток сбрасывает флаг критической секции;
		\item Вычислительные потоки синхронизируются;
		\item Каждый вычислительный поток пытается установить флаг критической секции - пытается занять критическую секцию.

			Для установа флага критической секции вычислительные потоки используют функцию atomic\_xchg(), описанную в стандарте OpenCL.

			Функция atomic\_xchg() устанавливает значение переменной, указатель на которую передан ей в первом параметре, в значение, указанное во втором параметре, возвращая при этом старое значение целевой переменной. Функция atomic\_xchg() гарантирует атомарность выполняемой операции - в некоторый момент времени только один вычислительный поток может выполнять описанную операцию, все прочие вычислительные потоки будут ожидать данный.

			Таким образом, вычислительный поток только тогда продолжит свое выполнение, когда ему удастся изменить значение переменной flag с нуля на единицу - то есть, когда ему удастся установить флаг, бывший в сброшенном состоянии;

		\item Вычислительный поток выполняет код критической секции, условно обозначенный в листинге \ref{listing:opencl:critical} как CRITICAL\_SECTION;
		\item Вычислительный поток сбрасывает флаг, освобождая тем самым критическую секцию.

	\end{enumerate}

	Для использования атомарных операций в исходный код программного модуля, выполняемого на целевом вычислительном устройстве, необходимо добавить вызов прагмы OPENCL EXTENSION со специальными параметрами активации расширений стандарта OpenCL, ответственных за реализацию атомарных операций. Вызов означенной прагмы должен быть размещен вне описаний функций. Синтаксис вызова прагмы OPENCL EXTENSION приведен в листинге \ref{listing:opencl:critical:act}.

\mylistingbegin{opencl:critical:act}{Прагма OPENCL EXTENSION}
\begin{lstlisting}

#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable
#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable

\end{lstlisting}
\mylistingend

	\mysubparagraph{Библиотека функций}

		TODO

	\mysubparagraph{Некоторые особенности OpenCL - диалекта языка программирования C}

		Тип данных double реализуется как расширение к диалекту и поддерживается не всеми вычислительными устройствами. В целях повышения переносимости программ между аппаратными платформами для операций над вещественными числами рекомендуется использовать тип данных float.

\myparagraph{Программный модуль, выполняемый на управляющем вычислительном устройстве}

	TODO

