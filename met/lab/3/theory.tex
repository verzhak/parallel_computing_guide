
\mysubsubsection{Введение}

Одной из современных тенденций в организации параллельных и распределенных вычислений стало распределение вычислений среди нескольких графических процессоров (GPU).

Первой компанией, представившей рынку промышленный стандарт произвольных вычислений на графическом процессоре (GPGPU), стала компания NVIDIA, выпустившая в 2007-м году комплект разработчика (SDK) CUDA для своих графических процессоров серий GeForce, Tesla и Quadro.

Ответом компании ATI (ныне входящей в состав компании AMD) на выпуск SDK CUDA стал выход SDK Close to Metal и, позже, SDK FireStream, пришедшего на смену SDK Close to Metal.

Каждый из перечисленных SDK реализует свой собственный интерфейс работы с графическими процессорами, поддерживаемый только теми графическими процессорами, которые выпускает компания - разработчик SDK. Стандартом, который позволил бы разработчикам создавать переносимые многопоточные приложения, использующие для организации параллельных и распределенных вычислений несколько GPU, стал стандарт OpenCL, созданный компанией Apple и поддерживаемый промышленным консорциумом Khronos Group.

Стандарт OpenCL ((англ.) Open Computing Language - открытый язык вычислений) предназначен для организации параллельных и распределенных вычислений на различных типах процессоров, к которым относятся, прежде всего, графические процессоры (GPU) и центральные процессоры (CPU).

Стандарт OpenCL выпущен компанией Apple в 2008-м году и в настоящее время поддерживается промышленным консорциумом Khronos Group \cite{khronos}. Стандарт OpenCL является открытым - документация к нему находится в открытом доступе на сайте Khronos Group \cite{opencl}.

Стандарт OpenCL реализуется ключевыми производителями графических процессоров (NVIDIA, AMD и Intel) в соответствующих SDK, что позволяет разработчику создавать переносимые между различными аппаратными платформами приложения, использующие GPU и CPU для организации параллельных и распределенных вычислений. Существуют следующие бесплатные реализации стандарта OpenCL:

\begin{itemize}

	\item Реализация от компании NVIDIA - входит в состав SDK CUDA.

		Данная реализация поддерживает только GPU, выпущенные компанией NVIDIA и поддерживающие технологию GPGPU;

	\item Реализация от компании AMD - входит в состав SDK FireStream.

		Данная реализация поддерживает CPU архитектур IA-32 и x86-64 и GPU, выпущенные компанией AMD (ATI) и поддерживающие технологию GPGPU;

	\item Реализация от компании Intel - Intel OpenCL SDK.

		Данная реализация поддерживает только CPU архитектур IA-32 и x86-64, поддерживающих, в свою очередь, набор инструкций Intel Streaming SIMD Extensions (SSE) версии 4.1 и выше.

\end{itemize}

Программа, написанная с использованием стандарта OpenCL, состоит из программных модулей:

\begin{itemize}

	\item Программный модуль, выполняемый на целевом вычислительном устройстве (на целевом процессоре - GPU или CPU).
	
		Данный программный модуль состоит из набора подпрограмм - ядер (главных функций) вычислительных потоков, и набора дополнительных к ядрам подпрограмм.

		Параллельные и распределенные вычисления, реализуемые с помощью стандарта \linebreak OpenCL, заключаются в одновременном выполнении одного и того же ядра несколькими вычислительными потоками.

		Исходный код программного модуля, выполняемого на целевом вычислительном устройстве, должен быть написан на специальном диалекте языка программирования C. Означенный диалект частично совместим со стандартом C99 - так, например, диалект языка C из стандарта OpenCL не содержит стандартную библиотеку языка - вместо нее в стандарте OpenCL описана собственная библиотека функций;

	\item Программный модуль, выполняемый на управляющем устройстве (управляющий программный модуль).

		Данный программный модуль контролирует работу программного модуля, выполняемого на целевом вычислительном устройстве - компилирует исходный код означенного программного модуля, определяет фактические параметры ядер вычислительных потоков, запускает ядра вычислительных потоков на выполнение на целевом вычислительном устройстве, анализирует результаты выполнения ядер вычислительных потоков.

		Стандарт OpenCL описывает функционал, с помощью которого управляющий программный модуль взаимодействует с программным модулем, выполняемом на целевом вычислительном устройстве.

\end{itemize}

Принципиальная схема организации параллельных и распределенных вычислений с помощью стандарта OpenCL приведена на рисунке \ref{image:opencl:struct}.

\begin{landscape}
~
\vfill
\mimage{opencl:struct}{opencl-struct.eps}{Принципиальная схема организации параллельных и распределенных вычислений с помощью стандарта OpenCL}{width=\linewidth}
\vfill
~
\end{landscape}

В основе организации параллельного выполнения вычислительных потоков лежит управляющий программный модуль, определяющий количество выполняемых вычислительных потоков, значения параметров их ядер, запускающий на выполнения ядра вычислительных потоков и анализирующий результаты выполнения ядер вычислительных потоков.

Вычислительные потоки ((англ.) work-item - рабочие единицы) объединяются в группы потоков ((англ.) work-group - рабочие группы). На вычислительном устройстве может одновременно выполняться несколько групп потоков, при этом вычислительное устройство самостоятельно (на аппаратном или программном, но скрытом от разработчика, уровнях) распределяет вычислительные ресурсы между группами вычислительных потоков и вычислительными потоками в каждой из данных групп. Для каждого вычислительного устройства существуют собственные ограничения на количество одновременно выполняемых групп вычислительных потоков и количество вычислительных потоков в каждой из них.

Все вычислительные потоки разделяют глобальную, доступную им на чтение и запись, и константную, доступную им только на чтение, память. Потоки, входящие в одну группу, разделяют локальную память группы, доступную им на чтение и запись. Каждый из вычислительных потоков обладает также своей собственной, доступной только ему, локальной памятью.

Доступ к локальной памяти потока занимает меньше всего времени, однако объем локальной памяти не превышает несколько килобайт. Второй по скорости доступа и большей по объемую по сравнению с локальной памятью потока является локальная память группы вычислительных потоков. Наконец, самыми объемными, но в то же время самыми медленными, являются глобальная и константная память.

Управляющий программный модуль имеет доступ к глобальной (на чтение и запись) и константной (на запись) памяти, что позволяет ему организовать канал передачи данных между ним и ядрами вычислительных потоков.

Перед запуском вычислительных потоков управляющий программный модуль определяет размерность пространства вычислительных потоков (доступны одно-, двух- и трехмерные пространства) и размер пространства по каждой из размерностей. Каждый вычислительный поток, таким образом, идентифицируется своим собственным вектором целочисленных неотрицательных координат. В простейшем случае - размерность пространства равна единице - вектора координат вычислительных потоков эквиваленты последовательной нумерации вычислительных потоков, начиная с нуля.

\mysubsubsection{Программный модуль, выполняемый на целевом вычислительном устройстве}

	\myparagraph{Ядра вычислительных потоков и сопроводительный к ним функционал}

		Исходный код программного модуля, выполняемого на целевом вычислительном устройстве, суть есть совокупность описаний следующих функций:

		\begin{itemize}

			\item Ядра вычислительных потоков.

				Прототип ядра вычислительного потока должно предворять ключевое слово \verb|kernel| или ключевое слово \verb|__kernel|.

				Ядро вычислительного потока не должно ничего возвращать (типом его возвращаемого значения должен быть void);

			\item Прочие функции.

				Описываются как обычные функции языка программирования C.

		\end{itemize}

	\myparagraph{Описание переменных. Квалификаторы памяти}

		Для явного указания типа памяти, в которой должна быть размещена объявляемая переменная, при объявлении переменной перед указанием ее типа ставится один из следующих квалификаторов памяти:

		\begin{itemize}

			\item \verb|global| или \verb|__global| - переменная будет расположена в глобальной памяти;
			\item \verb|constant| или \verb|__constant| - переменная будет расположена в константной памяти.

			Ключевое слово \verb|const| языка программирования C также доступно и означает, что значение переменной невозможно изменить;

			\item \verb|local| или \verb|__local| - переменная будет расположена в локальной памяти группы вычислительных потоков;
			\item \verb|private| или \verb|__private| - переменная будет расположена в локальной памяти вычислительного потока.

		\end{itemize}

		Переменная без квалификатора располагается в локальной памяти вычислительного потока. Допускается указывать только один квалификатор памяти.

		При задании списка параметров ядер вычислительных потоков необходимо учитывать следующие особенности:

		\begin{itemize}

			\item Параметр - указатель на область памяти - должен быть размещен в глобальной или константной памяти, поскольку область памяти, на которую он указывает, создана и инициализирована управляющим программным модулем, который имеет доступ только к глобальной и константной памяти;

			\item Прочие параметры функции могут быть расположены в локальной памяти вычислительного потока, так как их установ главным потоком происходит с использованием функционала, непосредствено не имеющего доступ к локальной памяти вычислительного потока.

		\end{itemize}

	\myparagraph{Позиционирование вычислительного потока}

		Вычислительный поток может получить свою координату по какому-либо измерению с помощью функции {\bf get\_global\_id()}, прототип которой приведен в листинге \ref{listing:opencl:ggi}.

\mylistingbegin{opencl:ggi}{Функция get\_global\_id()}
\begin{lstlisting}

size_t get_global_id(unsigned dim);

\end{lstlisting}
\mylistingend

		Определить протяженность пространства вычислительных потоков по какому-либо измерению вычислительный поток может с помощью функции {\bf get\_global\_size()}, прототип которой приведен в листинге \ref{listing:opencl:gws}.

\mylistingbegin{opencl:gws}{Функция get\_global\_size()}
\begin{lstlisting}

size_t get_global_size(unsigned dim);

\end{lstlisting}
\mylistingend

		Единственными параметрами функций get\_global\_id() и get\_global\_size() являются номера интересующего вычислительный поток измерения (отсчет координат и нумерация измерений начинаются с нуля).

		Определить размерность пространства вычислительных потоков вычислительный поток может с помощью функции {\bf get\_work\_dim()}, прототип которой приведен в листинге \ref{listing:opencl:gwd}.

\mylistingbegin{opencl:gwd}{Функция get\_work\_dim()}
\begin{lstlisting}

unsigned get_work_dim();

\end{lstlisting}
\mylistingend

	\myparagraph{Синхронизация вычислительных потоков. Критические секции кода}

		Для синхронизации выполнения вычислительных потоков, составляющих группу вычислительных потоков, может быть использована функция {\bf barrier()}, прототип которой приведен в листинге \ref{listing:opencl:barrier}.

\mylistingbegin{opencl:barrier}{Функция barrier()}
\begin{lstlisting}

void barrier(0);

\end{lstlisting}
\mylistingend

		Функция barrier() блокирует выполнение вычислительного потока до тех пор, пока все остальные вычислительные потоки из группы данного вычислительного потока не выполнят функцию barrier().

		Стандарт OpenCL не содержит функционал организации критических секций кода - критические секции могут быть организованы разработчиком с помощью прочего функционала стандарта OpenCL. Один из способов организации критической секции для вычислительных потоков, входящих в одну группу, приведен в листинге \ref{listing:opencl:critical}.

\mylistingbegin{opencl:critical}{Организация критической секции для группы вычислительных потоков}
\begin{lstlisting}

__local int flag;

if(! get_global_id())
	flag = 0;

barrier(0);

while(atomic_xchg(& flag, 1));

CRITICAL_SECTION;

atomic_xchg(& flag, 0);

\end{lstlisting}
\mylistingend

	Приведенная выше реализация критической секции работает по следующему алгоритму:

	\begin{enumerate}

		\item Группа вычислительных потоков описывает целочисленную переменную flag, расположенную в локальной памяти группы. Целочисленная переменная flag будет использоваться как флаг критической секции - признаком свободной критической секции будет значение 0 переменной flag (флаг сброшен), признаком занятой критической секции - ненулевое значение переменной flag (флаг установлен);
		\item Нулевой вычислительный поток сбрасывает флаг критической секции;
		\item Вычислительные потоки синхронизируются;
		\item Каждый вычислительный поток пытается установить флаг критической секции - пытается занять критическую секцию.

			Для установа флага критической секции вычислительные потоки используют функцию atomic\_xchg(), описанную в стандарте OpenCL.

			Функция atomic\_xchg() устанавливает значение переменной, указатель на которую передан ей в первом параметре, в значение, указанное во втором параметре, возвращая при этом старое значение целевой переменной. Функция atomic\_xchg() гарантирует атомарность выполняемой операции - в некоторый момент времени только один вычислительный поток может выполнять описанную операцию, все прочие вычислительные потоки будут ожидать данный.

			Таким образом, вычислительный поток только тогда продолжит свое выполнение, когда ему удастся изменить значение переменной flag с нуля на единицу - то есть, когда ему удастся установить флаг, бывший в сброшенном состоянии;

		\item Вычислительный поток выполняет код критической секции, условно обозначенный в листинге \ref{listing:opencl:critical} как CRITICAL\_SECTION;
		\item Вычислительный поток сбрасывает флаг, освобождая тем самым критическую секцию.

	\end{enumerate}

	Для использования атомарных операций в исходный код программного модуля, выполняемого на целевом вычислительном устройстве, необходимо добавить вызов прагмы OPENCL EXTENSION со специальными параметрами активации расширений стандарта OpenCL, ответственных за реализацию атомарных операций. Вызов означенной прагмы должен быть размещен вне описаний функций. Синтаксис вызова прагмы OPENCL EXTENSION приведен в листинге \ref{listing:opencl:critical:act}.

\mylistingbegin{opencl:critical:act}{Прагма OPENCL EXTENSION}
\begin{lstlisting}

#pragma OPENCL EXTENSION cl_khr_local_int32_base_atomics : enable
#pragma OPENCL EXTENSION cl_khr_local_int32_extended_atomics : enable

\end{lstlisting}
\mylistingend

	\myparagraph{Библиотека функций}

		В библиотеке функций доступны математические функции, описанные в стандарте C99 языка программирования C.

	\myparagraph{Некоторые особенности OpenCL-диалекта языка программирования C}

		Тип данных double реализуется как расширение к диалекту и поддерживается не всеми вычислительными устройствами. В целях повышения переносимости программ между аппаратными платформами для операций над вещественными числами рекомендуется использовать тип данных float.

\mysubsubsection{Программный модуль, выполняемый на управляющем вычислительном устройстве}

	В исходный код управляющего программного модуля с помощью диррективы include компилятора должно быть включено содержимое заголовочного файла CL/cl.h.

	Стандарт OpenCL описывает собственную систему типов данных, основанную на системе типов данных языка программирования C. Соответствия типов данных стандарта OpenCL типам данных языка программирования C приведены в таблице \ref{table:opencl:dtype}.

\newcommand{\dtype}[2]{#1 & #2 \\}

\begin{longtable}[H]{|L|L|}

	\multicolumn{2}{r}{Таблица~\thetable~---~Типы данных, описанные в стандарте OpenCL} \\

	\hline
	\bf OpenCL & \bf C \\
	\hline

	\label{table:opencl:dtype}
	\dtype{-}{bool}
	\dtype{cl\_char}{char}
	\dtype{cl\_uchar}{unsigned char}
	\dtype{cl\_short}{short}
	\dtype{cl\_ushort}{unsigned short}
	\dtype{cl\_int}{int}
	\dtype{cl\_uint}{unsigned}
	\dtype{cl\_long}{long}
	\dtype{cl\_ulong}{unsigned long}
	\dtype{cl\_float}{float}
	\dtype{-}{size\_t}
	\dtype{void}{void}

	\hline

\end{longtable}

% ############################################################################ 

\newcommand{\openclfunc}{}

\newcommand{\openclbegin}[4]
{
	\renewcommand{\openclfunc}{#1()\xspace}

	\item #2.

		Для #3~управляющий программный модуль должен воспользоваться функцией {\bf \openclfunc}, прототип которой приведен в листинге \ref{listing:opencl:#4}.

\mylistingbegin{opencl:#4}{Функция \openclfunc}
}

\newcommand{\openclend}[2]
{
\mylistingend

	Функция \openclfunc имеет следующие параметры:

	\begin{itemize}

		#1

	\end{itemize}

	Функция \openclfunc возвращает #2
}

\newcommand{\openclsimpleend}[3]
{
\mylistingend

	Параметром #1 в функцию \openclfunc передается #2.

	Функция \openclfunc возвращает #3
}

\newcommand{\openclsuccess}
{значение константы компилятора \linebreak CL\_SUCCESS в случае своего успешного завершения и значение, отличное от значения данной константы компилятора, в противном случае}
\newcommand{\openclsuccessfinish}
{значение константы компилятора CL\_SUCCESS в случае своего успешного завершения и значение, отличное от значения данной константы компилятора, в противном случае}

\newcommand{\errcode}{\item errcode\_ret - указатель на целочисленную переменную, в которую функция \linebreak \openclfunc запишет значение константы компилятора CL\_SUCCESS в случае своего успешного завершения и значение, отличное от значения данной константы компилятора, в противном случае.}
\newcommand{\errcodeslb}{\item errcode\_ret - указатель на целочисленную переменную, в которую функция \linebreak \openclfunc запишет значение константы компилятора \linebreak CL\_SUCCESS в случае своего успешного завершения и значение, отличное от значения данной константы компилятора, в противном случае.}

% ############################################################################ 

	Управляющий программный модуль организует параллельные вычисления на целевом вычислительном устройстве по следующему алгоритму:

	\begin{enumerate}

%% ############################################################################ 

		\openclbegin{clGetPlatformIDs}{Получение идентификатора используемой реализации стандарта OpenCL}{получения идентификатора используемой реализации стандарта OpenCL}{gpid}

\begin{lstlisting}

cl_int clGetPlatformIDs(cl_uint num_entries, cl_platform_id * platforms, cl_uint * num_platforms);

\end{lstlisting}

		\openclend
		{
			\item num\_entries - количество элементов в массиве platforms;
			\item platforms - массив, в котором функция \openclfunc возвращает идентификаторы доступных управляющему программному модулю реализаций стандарта OpenCL;
			\item num\_platforms - указатель на целочисленную беззнаковую переменную, в которой функция \openclfunc возвращает количество идентификаторов реализаций стандарта OpenCL, записанных в массив platforms.
		}
		{\openclsuccess.~Кроме того, неудачным также следует считать вызов функции \openclfunc в том случае, если по возврату из функции значение переменной, на которую указывает параметр num\_platforms, равно нулю - в этом случае управляющему программному модулю по той или иной причине не доступна ни одна реализация стандарта OpenCL;}

% ############################################################################ 

		\openclbegin{clGetDeviceIDs}{Получение идентификатора вычислительного устройства, на котором будут выполнятся вычислительные потоки}{получения идентификатора вычислительного устройства}{gdid}

\begin{lstlisting}

cl_int clGetDeviceIDs(cl_platform_id platform, cl_device_type device_type, cl_uint num_entries, cl_device_id * devices, cl_uint * num_devices);

\end{lstlisting}

		\openclend
		{
			\item platform - идентификатор используемой реализации стандарта OpenCL;
			\item device\_type - идентификатор типа вычислительного устройства, идентификатор которого хочет получить управляющий программный модуль.

				Параметр device\_type может принимать следующие значения:

				\newcommand{\ndtl}[2]{\item CL\_DEVICE\_TYPE\_#1 - #2;}

				\begin{itemize}

					\ndtl{CPU}{центральный процессор (CPU)}
					\ndtl{GPU}{графический процессор (GPU)}
					\ndtl{ACCELERATOR}{специализированный ускоритель}
					\ndtl{DEFAULT}{устройство по умолчанию для данной реализации стандарта OpenCL}
					\ndtl{ALL}{любое вычислительное устройство}

				\end{itemize}

			\item num\_entries - количество элементов в массиве devices;
			\item devices - массив, в котором функция \openclfunc возвращает идентификаторы доступных управляющему программному модулю вычислительных устройств;
			\item num\_devices - указатель на целочисленную беззнаковую переменную, в которой функция \openclfunc возвращает количество идентификаторов вычислительных устройств, записанных в массив devices.
		}
		{\openclsuccess.~Кроме того, неудачным также следует считать вызов функции \openclfunc в том случае, если по возврату из функции значение переменной, на которую указывает параметр num\_devices, равно нулю - в этом случае управляющему программному модулю по той или иной причине не доступно ни одно вычислительное устройство;}

% ############################################################################ 

		\openclbegin{clCreateContext}{Создание контекста вычислений}{создания контекста вычислений}{cc}

\begin{lstlisting}

cl_context clCreateContext(NULL, 1, const cl_device_id * devices, NULL, NULL, cl_int * errcode_ret);

\end{lstlisting}

		\openclend
		{
			\item devices - указатель на идентификатор используемого вычислительного устройства;
			\errcode
		}
		{описатель контекста вычислений;}

% ############################################################################ 

		\openclbegin{clCreateCommandQueue}{Создание очереди команд}{создания очереди команд, отправляемых используемому вычислительному устройству управляющим программным модулем,}{ccq}
		
\begin{lstlisting}

cl_command_queue clCreateCommandQueue(cl_context context, cl_device_id device, 0, cl_int * errcode_ret);

\end{lstlisting}

		\openclend
		{
			\item context - описатель контекста вычислений;
			\item device - идентификатор используемого вычислительного устройства;
			\errcode
		}
		{описатель очереди команд;}

% ############################################################################ 

		\item Считывание исходного кода программного модуля, выполняемого на используемом вычислительном устройстве;

% ############################################################################ 

		\openclbegin{clCreateProgramWithSource}{Создание описателя программного модуля, выполняемого на используемом вычислительном устройстве}{создания описателя программного модуля, выполняемого на используемом вычислительном устройстве,}{cpws}

\begin{lstlisting}

cl_program clCreateProgramWithSource(cl_context context, 1, const char ** strings, const size_t * lengths, cl_int * errcode_ret);

\end{lstlisting}

		\openclend
		{
			\item context - описатель контекста вычислений;
			\item strings - указатель на строку, содержащую исходный код программного модуля, выполняемого на используемом вычислительном устройстве;
			\item lengths - указатель на переменную, содержащую размер в байтах строки, на которую указывает параметр strings;
			\errcodeslb
		}
		{Описатель программного модуля, выполняемого на используемом вычислительном устройстве;}

% ############################################################################ 

		\openclbegin{clBuildProgram}{Компиляция программного модуля, выполняемого на используемом вычислительном устройстве}{компиляции программного модуля, выполняемого на используемом вычислительном устройстве,}{bp}

\begin{lstlisting}

cl_int clBuildProgram(cl_program program, 0, NULL, NULL, NULL, NULL);

\end{lstlisting}

		\openclsimpleend{program}{описатель программного модуля, выполняемого на используемом вычислительном устройстве}{\openclsuccess;}

% ############################################################################ 

		\openclbegin{clCreateKernel}{Создание описателя ядра вычислительных потоков}{создания описателя ядра вычислительных потокв}{ck}

\begin{lstlisting}

cl_kernel clCreateKernel(cl_program program, const char * kernel_name, cl_int * errcode_ret);

\end{lstlisting}

		\openclend
		{
			\item program - описатель программного модуля, выполняемого на используемом вычислительном устройстве;
			\item kernel\_name - строка, содержащая имя ядра вычислительных потоков, описатель которого создается;
			\errcode
		}
		{описатель ядра вычислительных потоков;}

% ############################################################################ 

		\openclbegin{clSetKernelArg}{Установ фактических значений параметров ядра вычислительных потоков}{установа фактического значения параметра ядра вычислительного потока}{ska}

\begin{lstlisting}

cl_int clSetKernelArg(cl_kernel kernel, cl_uint arg_index, size_t arg_size, const void * arg_value);

\end{lstlisting}

		\openclend
		{
			\item kernel - описатель ядра вычислительных потоков;
			\item arg\_index - номер параметра ядра вычислительных потоков, считая от нуля слева направо;
			\item arg\_size - размер параметра в байтах;
			\item arg\_value - указатель на переменную, содержащую устанавливаемое фактическое значение параметра.
		}
		{\openclsuccess.}

		В том случае, если целевой параметр является указателем, то управляющий программный модуль должен предварительно создать и, возможно, заполнить буфер в глобальной или константной памяти используемого вычислительного устройства. В этом случае управляющий программный модуль выполняет следующие действия:

		\begin{enumerate}

% ############################################################################ 

		\openclbegin{clCreateBuffer}{Создание буфера в глобальной / константной памяти используемого вычислительного устройства}{создания буфера}{cb}

\begin{lstlisting}

cl_mem clCreateBuffer(cl_context context, cl_mem_flags flags, size_t size, NULL, cl_int * errcode_ret);

\end{lstlisting}

		\openclend
		{
			\item context - описатель контекста вычислений;
			\item flags - (с некоторым допущением) флаг прав доступа вычислительных потоков к создаваемому буферу.

				Параметр flags может принимать следующие значения:

				\begin{itemize}

					\item 0 или CL\_MEM\_READ\_WRITE - буфер доступен на чтение и запись;
					\item CL\_MEM\_WRITE\_ONLY - буфер доступен только на запись (управляющему программному модулю буфер доступен только на чтение);
					\item CL\_MEM\_READ\_ONLY - буфер доступен только на чтение (управляющему программному модулю буфер доступен только на запись);
					
				\end{itemize}

			\item size - размер в байтах создаваемого буфера;
			\errcode
		}
		{описатель буфера;}

% ############################################################################ 

		\openclbegin{clEnqueueWriteBuffer}{Заполнение буфера}{заполнения буфера}{ewb}

\begin{lstlisting}

cl_int clEnqueueWriteBuffer(cl_command_queue command_queue, cl_mem buffer, CL_TRUE, 0, size_t cb, const void * ptr, 0, NULL, NULL);

\end{lstlisting}

		\openclend
		{
			\item command\_queue - описатель очереди команд;
			\item buffer - описатель буфера;
			\item cb - количество копируемых байт;
			\item ptr - указатель на буфер, расположенный в виртуальном адресном пространстве управляющего программного модуля - cb первых байт данного буфера будут скопированы в заполняемый буфер.
		}
		{\openclsuccess.}

		При передаче вычислительным потокам двухмерного массива \linebreak \verb|t_type ** data|, где \verb|t_type| - некоторый тип данных, а \verb|size| - размер массива по первой размерности, необходимо помнить, что данные в двухмерных массивах языка программирования C расположены построчно, начиная с адреса \verb|data + size|; % TODO как насчет [][]?

% ############################################################################ 

		\item Установ фактического значения параметра ядра вычислительных потоков.

			Для установа фактического значения параметра ядра вычислительных потоков управляющий программный модуль должен воспользоваться функцией \linebreak clSetKernelArg(), вызов которой для данного случая приведен в листинге \ref{listing:opencl:ska-special}.

\mylistingbegin{opencl:ska-special}{Вызов функции clSetKernelArg() для установа фактического значения параметра ядра вычислительных потоков, указывающего на буфер в глобальной / константной памяти}
\begin{lstlisting}

cl_int clSetKernelArg(cl_kernel kernel, cl_uint arg_index, sizeof(cl_mem), (void *) & buffer);

\end{lstlisting}
\mylistingend
			
			Здесь buffer суть есть описатель целевого буфера;

% ############################################################################ 

		\end{enumerate}

% ############################################################################ 

		\item Запуск вычислительных потоков.

			Для запуска вычислительных потоков управляющий программный модуль должен воспользоваться одной из следующих функций:

			\begin{enumerate}

% ############################################################################ 

				\openclbegin{clEnqueueTask}{Запуск одного вычислительного потока}{запуска одного вычислительного потока}{et}

\begin{lstlisting}

cl_int clEnqueueTask(cl_command_queue command_queue, cl_kernel kernel, 0, NULL, NULL);

\end{lstlisting}

				\openclend
				{
					\item command\_queue - описатель очереди команд;
					\item kernel - описатель ядра вычислительного потока.
				}
				{\openclsuccess;}

% ############################################################################ 

				\openclbegin{clEnqueueNDRangeKernel}{Запуск нескольких вычислительных потоков}{запуска нескольких вычислительных потоков}{endrk}

\begin{lstlisting}

cl_int clEnqueueNDRangeKernel(cl_command_queue command_queue, cl_kernel kernel, cl_uint work_dim, NULL, const size_t * global_work_size, const size_t * local_work_size, 0, NULL, NULL);

\end{lstlisting}

				\openclend
				{
					\item command\_queue - описатель очереди команд;
					\item kernel - описатель ядра вычислительных потоков;
					\item work\_dim - размерность пространства вычислительных потоков;
					\item global\_work\_size - указатель на массив размеров пространства вычислительных потоков по каждой из размерности;
					\item local\_work\_size - указатель на массив размеров групп вычислительных потоков по каждой из размерностей. Последняя группа вычислительных потоков организуется по остаточному принципу.

						Параметр local\_work\_size может принимать значение NULL - в этом случае размеры групп вычислительных потоков определяет супервизор.
				}
				{\openclsuccess;}

% ############################################################################ 

			\end{enumerate}

% ############################################################################ 

		\openclbegin{clEnqueueReadBuffer}{Чтение содержимого буфера}{чтения содержимого буфера, расположенного в глобальной / константной памяти используемого вычислительного устройства и доступного управляющему программному модулю на чтение,}{erb}

\begin{lstlisting}

cl_int clEnqueueReadBuffer(cl_command_queue command_queue, cl_mem buffer, CL_TRUE, 0, size_t cb, const void * ptr, 0, NULL, NULL);

\end{lstlisting}

		\openclend
		{
			\item command\_queue - описатель очереди команд;
			\item buffer - описатель буфера;
			\item cb - количество копируемых байт;
			\item ptr - указатель на буфер, расположенный в виртуальном адресном пространстве управляющего программного модуля - в начало данного буфера будет записано cb первых байт читаемого буфера.
		}
		{\openclsuccess;}

% ############################################################################ 

		\openclbegin{clFinish}{Ожидание завершения выполнения всех команд, помещенных в очередь команд}{ожидания завершения выполнения всех команд, помещенных в очередь команд,\linebreak}{finish}

\begin{lstlisting}

cl_int clFinish(cl_command_queue command_queue);

\end{lstlisting}

		\openclsimpleend{command\_queue}{описатель очереди команд}
		{
		\openclsuccessfinish.

		Вызов функции \openclfunc гарантирует, что все операции чтения / записи буферов, установа аргументов ядер вычислительных потоков были корректно завершены, а сами вычислительные потоки выполнили необходимые вычисления;
		}

% ############################################################################ 

		\item Освобождение ресурсов.

			По завершению выполнения параллельных вычислений управляющий программный модуль должен корректно освободить все, занятые им, ресурсы, для чего ему необходимо воспользоваться следующими функциями:

			\newcommand{\openclfirstrelease}[2]{\item {\bf clRelease#1()} - удаляет описатель #2, переданный в функцию первым и единственным параметром}
			\newcommand{\openclrelease}[2]{\item {\bf clRelease#1()} - удаляет описатель #2}

			\begin{itemize}

				\openclrelease{MemObject}{буфера};
				\openclrelease{Kernel}{ядра вычислительных потоков};
				\openclrelease{Program}{программного модуля, выполнявшегося на используемом вычислительном устройстве};
				\openclrelease{CommandQueue}{очереди команд};
				\openclrelease{Context}{контекста вычислений}.

			\end{itemize}

			Каждая из перечисленных функций возвращает \openclsuccess.

% ############################################################################ 

\end{enumerate}

