
В качестве демонстрационного примера рассмотрим моделирование логнормального распределения с помощью датчика псевдослучайных чисел, равномерно распределенных на диапазоне $[0 ;~ 1)$.

Плотность логнормального распределения вычисляется по формуле \eqref{logn:distrib}.
\begin{gather}
	f(x) = \frac{1}{\sqrt{2\pi}x\sigma}e^{-\dfrac{(\ln(x) - \mu)^2}{2\sigma^2}}\label{logn:distrib} \\
	\mu, \sigma \in \mathbb{R} \notag
\end{gather}

Математическое ожидание случайной величины с логнормальным распределением равно $e^{\mu + \frac{\sigma^2}{2}}$. Дисперсия случайной величины с логнормальным распределением равна $(e^{2\mu + \sigma^2}(e^{\sigma^2}- 1))$.

Генерирование реализации $\xi$ псевдослучайной величины с логнормальным распределением происходит по формуле \eqref{logn:gen}.
\begin{gather}
	\xi = e^\theta \label{logn:gen}
\end{gather}

В формуле \eqref{logn:gen} величина $\theta$ суть есть реализация псевдослучайной величины с нормальным распределением, параметры которого равны параметрам $\mu$, $\sigma$ логнормального распределения.

Реализацию $\theta$ псевдослучайной величины с нормальным распределением можно сгенерировать с помощью преобразования Бокса - Мюллера \eqref{logn:normal:gen}.
\begin{gather}
	\theta = \sigma ~ \cos(2 \pi z_0) ~ \sqrt{-2 \ln(z_1)} + \mu \label{logn:normal:gen}
\end{gather}

В формуле \eqref{logn:normal:gen} величины $z_0$, $z_1$ суть есть реализации независимых друг от друга псевдослучайных величин, равномерно распределенных на диапазоне $[0 ;~ 1]$. В настоящем демонстрационном примере в качестве величин $z_0$ и $z_1$ используются реализации одной и той же псевдослучайной величины (реализации, сгенерированные одним и тем же датчиком псевдослучайных чисел), равномерно распределенной на диапазоне $[0 ;~ 1)$.

Исходный код главной программы приведен в листинге \ref{listing:opencl:src:main.c}. В листинге \ref{listing:opencl:src:kernel.c} приведен исходный код ядер (главных функций) вычислительных потоков.

Рисунком \ref{image:opencl:build} проиллюстрирован процесс сборки демонстрационной программы. На рисунках \ref{image:opencl:demo:1}, \ref{image:opencl:demo:2}, \ref{image:opencl:demo:3}, \ref{image:opencl:demo:4} и \ref{image:opencl:demo:5} приведены результаты вычислений, выполненных одним, десятью, сотней, пятистами и тысячью вычислительными потоками соответственно.

% \mysource{../src/demo_2/opencl/main.c}{opencl:src:main.c}{Исходный код демонстрационной программы (главная программа; хост - программа)}
% \mysource{../src/demo_2/opencl/kernel.c}{opencl:src:kernel.c}{Исходный код демонстрационной программы (ядра (главные функции) вычислительных потоков)}

% \mysource{../src/demo_2/opencl/main_critical.c}{opencl:src:main.c}{Исходный код демонстрационной программы (главная программа; хост - программа)} % TODO раскомментировать
% \mysource{../src/demo_2/opencl/kernel_critical.c}{opencl:src:kernel.c}{Исходный код демонстрационной программы (ядра (главные функции) вычислительных потоков)} % TODO раскомментировать

\mimage{opencl:build}{701}{Сборка демонстрационной программы}{}
\mimage{opencl:demo:1}{710}{Результат вычислений, выполненных одним вычислительным потоком}{}
\mimage{opencl:demo:2}{711}{Результат вычислений, выполненных десятью вычислительными потоками}{}
\mimage{opencl:demo:3}{712}{Результат вычислений, выполненных сотней вычислительных потоков}{}
\mimage{opencl:demo:4}{709}{Результат вычислений, выполненных пятистами вычислительными потоками}{}
\mimage{opencl:demo:5}{705}{Результат вычислений, выполненных тысячью вычислительных потоков}{}

