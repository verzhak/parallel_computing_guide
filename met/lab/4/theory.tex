
\mysubsubsection{Введение}

Использование языков программирования общего назначения (C, C++, Java, Python и прочих) для организации параллельных и распределенных вычислений часто оказывается неудобным по следующим причинам:

\begin{itemize}

	\item Язык программирования и его стандартная библиотека не содержат функционал, позволяющий организовать параллельные и распределенные вычисления, по причине стремления разработчиков языка к максимальному упрощению спецификации языка для возможности его реализации на максимально большом количестве аппаратных и программных платформ (язык программирования C, частично это утверждение относится и к языку программирования C++).

	В данном случае программист вынужден использовать сторонние библиотеки, реализующие общепринятые стандарты организации параллельных и распределенных вычислений, что негативно сказывается на простоте и понятности исходного кода и, самое главное, на его переносимости между платформами;

	\item Дизайн языка программирования изначально не был рассчитан на организацию параллельных и распределенных вычислений, хотя ограниченный функционал для реализаций таковых вычислений присутствует в стандартной библиотеке языка программирования (язык программирования Python).

	В данном случае программист вынужден использовать сторонние библиотеки, позволяющие организовывать параллельные и распределенные вычисления, и написанные, возможно, на языках программирования, отличных от используемого, что негативно сказывается на простоте, понятности и переносимости исходного кода и делает программу зависимой от сторонней и, возможно, не так хорошо отлаженной, как того требуется программисту, библиотеке;

	\item Язык программирования и его стандартная библиотека ориентированы на решение максимально широкого круга задач (в том числе - и на организацию параллельных и распределенных вычислений; язык программирования Java).

	В данном случае программист вынужден работать со стандартной библиотекой, реализации алгоритмов в которой, в большинстве случаев, не являются параллельными (если рассматриваемый алгоритм вообще поддается распараллеливанию) - программист вынужден разрабатывать своб собственную библиотеку (или использовать сторонние библиотеки), содержащую параллельные реализации алгоритмов, нужных программисту.

	К недостаткам рассматриваемых языков программирования относится также и тот факт, что часто программы, разработанные с их помощью, выполняются не в виде бинарного кода на процессоре, а в виде байт-кода на виртуальной машине языка программирования, что негативно сказывается на временной эффективности выполняемых программой вычислений, поскольку виртуальные машины часто оказываются недостаточно оптимизированными для выполнения параллельных вычислений.

\end{itemize}

Очевидно, что для упрощения процесса организации эффективных параллельных и распределенных вычислений, требуется язык программирования, изначально спроектированный для организации таковых вычислений - то есть язык параллельного программирования.

На настоящий момент наибольшей популярностью пользуются следующие языки параллельного программирования:

\begin{itemize}

	\item Alice (Саарский университет - Германия; 2002-ой год) - функциональный язык программирования, один из диалектов языка программирования Standart ML;
	\item Cilk, Cilk++ (Intel, ранее Cilk Arts - США; 1994 год) , T++ (Институт программных систем РАН; 80-е года XX-го века) - языки параллельного программирования, основанные на языках программирования C и C++;
	\item Erlang (Ericsson Computer Science Laboratory - Швеция; 1987-ой год) - функциональный язык программирования, основанный на языке программирования Prolog;
	\item Occam (Оксфордский университет - Великобритания; 1983-ий год) - процедурный язык параллельного программирования.

\end{itemize}

В настоящей лабораторной работе рассматривается язык программирования Erlang.

\mysubsubsection{Язык программирования Erlang}

Язык программирования Erlang \cite{erlang} суть функциональный язык программирования с динамической типизацией, позволяющий быстро и компактно\footnote{Имеется в виду минимизация объема исходного кода.} организовывать параллельные и распределенные вычисления. Erlang разработан и поддерживается компанией Ericsson.

Erlang относится к классу языков программирования, выполняющих программный код на собственной виртуальной машине. Исходный код программных модулей предварительно компилируется виртуальной машиной в байт-код, который ею и выполняется. Виртуальная машина Erlang'а оптимизирована для организации параллельных вычислений, что позволяет программисту, к примеру, запускать десятки тысяч вычислительных потоков на одной виртуальной машине без существенных потерь оперативной памяти на хранение различного рода служебной информации о потоках. Отличительными чертами Erlang'а от прочих языков программирования являются дешевая рекурсия и философия <<Let it crash>> (<<пусть падает>>), требующая от программиста выделять программный код, склонный к аварийным завершениям, в отдельный вычислительный поток, единственной реакцией на аварийное завершение которого должен быть его повторный запуск, если того требует логика программы.

\mysubsubsection{Виртуальная машина языка программирования Erlang}

Виртуальная машина языка программирования Erlang поддерживает два режима работы - интерактивный и неинтерактивный:

\begin{itemize}

	\item Интерактивный режим работы.

	Интерактивный режим работы заключается в непосредственном вводе программистом инструкций на языке программирования Erlang.

	Для запуска виртуальной машины необходимо выполнить команду, приведенную в листинге \ref{listing:erlang:virt-start}.

\mylistingbegin{erlang:virt-start}{Запуск виртуальной машины}
\begin{lstlisting}

erl -name NAME@IP_ADDR

\end{lstlisting}
\mylistingend

	Здесь:
	
	\begin{itemize}
	
		\item NAME - имя вычислительного узла, ассоциируемого с запущенной копией виртуальной машины;
		\item IP\_ADDR - IPv4-адрес сетевого интерфейса вычислительной системы, подключения к одному из TCP-портов которого (как правило, порт 4369) виртуальная машина будет ожидать.

	\end{itemize}

	Ключ <<-name NAME@IP\_ADDR>> можно опустить - в этом случае виртуальная машина не будет доступна из-вне.

	Доступ к виртуальной машине из-вне означает, что другая (удаленная) виртуальная машина может подключится к данной и в фоновом режиме запустить на ней несколько вычислительных потоков. Для программиста нет серьезной разницы в том, где выполняется вычислительный поток - на виртуальной машине, оператором которой он является, или на удаленной виртуальной машине - единственное различие имеет место быть в параметрах, передаваемых функции spawn() при запуске потока.

	Виртуальные машины реализуют несколько способов идентификации и авторизации друг друга, простейшим (и принятым по умолчанию) из которых является способ, основанный на проверке совпадения строк - cookies:

	\begin{enumerate}

		\item Оператор первой вычислительной системы входит в систему под именем некоторого пользователя;
		\item Оператор первой вычислительной системы создает текстовый файл \linebreak \$HOME/.erlang.cookie, состоящий из единственной строки, начинающейся с прописной буквы латинского алфавита и содержащей символы латинского алфавита, цифры и знак подчеркивания;
		\item Оператор первой вычислительной системы запускает виртуальную машину языка программирования Erlang;
		\item Оператор второй вычислительной системы входит в систему под именем некоторого пользователя;
		\item Оператор второй вычислительной системы создает текстовый файл \linebreak \$HOME/.erlang.cookie, состоящий из единственной строки, начинающейся с прописной буквы латинского алфавита и содержащей символы латинского алфавита, цифры и знак подчеркивания;
		\item Оператор второй вычислительной системы запускает виртуальную машину языка программирования Erlang.

	\end{enumerate}

	Виртуальная машина, запущенная на первой вычислительной системе, будет успешно авторизована для запуска вычислительных потоков на виртуальной машине, запущенной на второй вычислительной системе, тогда и только тогда, когда первые строки файлов .erlang.cookie в домашних каталогах пользователей, запустивших виртуальные машины, будут совпадать;

	\item Неинтерактивный режим работы.

	Неинтерактивный режим работы заключается в написании программистом программного модуля с последующей компиляцией и запуском модуля на виртуальной машине.

	Исходный код программного модуля должен быть сохранен в файле с расширением .erl.
	
	Исходный код простого программного модуля приведен в листинге \ref{listing:erlang:simple-module}.

\mylistingbegin{erlang:simple-module}{Исходный код демонстрационного программного модуля}
\begin{lstlisting}

% Demo

-module(demo).
-import(math, [log / 1, sqrt / 1]).
-export([eval / 1]).

eval(X) -> sqrt(log(X)).

\end{lstlisting}
\mylistingend

	Здесь:

	\begin{itemize}

		\item Символ \% отмечает начало строки - комментария; окончание комментария отмечает символ перехода на следующую строку;
		\item Строка <<-module(demo).>> содержит название программного модуля (в рассматриваемом примере - demo); название программного модуля должно совпадать с именем файла, в котором сохранен исходный код модуля;
		\item Строка <<-import(math, [log / 1, sqrt / 1]).>> суть есть предписание импортировать из программного модуля math (присутствует в стандартной библиотеке) функций log() и sqrt(), каждая из которых обладает одним параметром;
		\item Строка <<-export([eval / 1]).>> содержит перечисление функций программного модуля, которые будут доступны другим программным модулям после загрузки модуля demo в виртуальную машину (в данном случае будет доступна только функция eval(), обладающая одним параметром).

		Экспортируемыми должны быть также главные функции вычислительных потоков, запускаемых функционалом, реализованным в данном программном модуле;

		\item Строка <<eval(X) -> sqrt(log(X)).>> содержит описание функции eval(), возвращающей квадратный корень из натурального логарифма значения своего единственного параметра (X).

	\end{itemize}

	После того, как исходный код программного модуля был сохранен в соответствующем файле (в рассматриваемом примере исходный код модуля demo должен быть сохранен в файле demo.erl), в каталоге, в котором находится файл с исходным кодом программного модуля, должна быть запущена виртуальная машина, которая выполнит компиляцию исходного кода программного модуля в байт-код, загрузку результата компиляции и запуск на выполнение одной из функций, экспортируемых программным модулем:

	\begin{itemize}

		\item Компиляция исходного кода программного модуля в байт-код и, одновременно, загрузка в виртуальную машину результирующего байт-кода выполняется с помощью функции c() (в рассматриваемом примере - <<c(demo).>>).

		Результат компиляции исходного кода программного модуля в байт-код сохраняется в файле с расширением .beam (в рассматриваемом примере - demo.beam);

		\item Загрузка в виртуальную машину байт-кода программного модуля из файла с расширением .beam выполняется с помощью функции nl() (в рассматриваемом примере функцию - <<nl(demo).>>).

	\end{itemize}

	В обоих случаях после загрузки в виртуальную машину байт-кода программного модуля, оператору виртуальной машины становятся доступными для вызова функции, экспортируемые программным модулем. Оператор виртуальной машины может вызвать любую функцию, экспортируемую модулем, с помощью оператора расширения пространства имен : (в рассматриваемом примере оператор может вызвать функцию eval(), экспортируемую модулем demo, с помощью инструкции <<demo:eval(NUM).>>, где NUM - некоторое целое или вещественное число).

	Необходимо помнить, что при организации параллельных и распределенных вычислений байт-код программного модуля должен быть загружен во всех виртуальных машинах, объединяемых в вычислительный кластер.

\end{itemize}

\mysubsubsection{Основные сведения о синтаксисе языка программирования Erlang}

\myparagraph{Объекты}

Erlang является языком программирования с динамической типизацией его объектов - то есть тип объекта определяется по присвоенному ему значению. Все объекты языка являются константными в том смысле, что их значение невозможно изменить после их объявлении (то есть после присвоения им значения).

Различают объекты следующих видов:

\begin{itemize}

	\item Переменные.

	Имена переменных могут содержать буквы латинского алфавита, цифры и символ подчеркивания, при этом первым символом в имени должна быть заглавная буква. Приблизительным аналогом переменных в Erlang'е являются именнованные константы в языке программирования C;

	\item Атомы.

TODO

\end{itemize}
	Атом -

\mysubsubsection{Параллельное программирование на языке программирования Erlang}

TODO

