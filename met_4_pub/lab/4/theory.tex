
% TODO_MET_4_PUB

\mysubsubsection{Введение}

Использование языков программирования общего назначения (C, C++, Java, Python и прочих) для организации параллельных и распределенных вычислений часто оказывается неудобным по следующим причинам:

\begin{itemize}

	\item язык программирования и его стандартная библиотека не содержат функционал, позволяющий организовать параллельные и распределенные вычисления, по причине стремления разработчиков языка к максимальному упрощению спецификации языка для возможности его реализации на максимально большом количестве аппаратных и программных платформ (язык программирования C, частично это утверждение относится и к языку программирования C++).

	В данном случае программист вынужден использовать сторонние библиотеки, реализующие общепринятые стандарты организации параллельных и распределенных вычислений, что негативно сказывается на простоте и понятности исходного кода и, самое главное, на его переносимости между платформами;

	\item дизайн языка программирования изначально не был рассчитан на организацию параллельных и распределенных вычислений, хотя ограниченный функционал для реализаций таковых вычислений присутствует в стандартной библиотеке языка программирования (язык программирования Python).

	В данном случае программист вынужден использовать сторонние библиотеки, позволяющие организовывать параллельные и распределенные вычисления, и написанные, возможно, на языках программирования, отличных от используемого, что негативно сказывается на простоте, понятности и переносимости исходного кода и делает программу зависимой от сторонней и, возможно, не так хорошо отлаженной, как того требуется программисту, библиотеке;

	\item язык программирования и его стандартная библиотека ориентированы на решение максимально широкого круга задач (в том числе - и на организацию параллельных и распределенных вычислений; язык программирования Java).

	В данном случае программист вынужден работать со стандартной библиотекой, реализации алгоритмов в которой, в большинстве случаев, не являются параллельными (если рассматриваемый алгоритм вообще поддается распараллеливанию) - программист вынужден разрабатывать своб собственную библиотеку (или использовать сторонние библиотеки), содержащую параллельные реализации алгоритмов, нужных программисту.

	К недостаткам рассматриваемых языков программирования относится также и тот факт, что часто программы, разработанные с их помощью, выполняются не в виде бинарного кода на процессоре, а в виде байт-кода на виртуальной машине языка программирования, что негативно сказывается на временной эффективности выполняемых программой вычислений, поскольку виртуальные машины часто оказываются недостаточно оптимизированными для выполнения параллельных вычислений.

\end{itemize}

Очевидно, что для упрощения процесса организации эффективных параллельных и распределенных вычислений, требуется язык программирования, изначально спроектированный для организации таковых вычислений - то есть язык параллельного программирования.

На настоящий момент наибольшей популярностью пользуются следующие языки параллельного программирования:

\begin{itemize}

	\item Alice (Саарский университет - Германия; 2002-ой год) - функциональный язык программирования, один из диалектов языка программирования Standart ML;
	\item Cilk, Cilk++ (Intel, ранее Cilk Arts - США; 1994 год) , T++ (Институт программных систем РАН; 80-е года XX-го века) - языки параллельного программирования, основанные на языках программирования C и C++;
	\item Erlang (Ericsson Computer Science Laboratory - Швеция; 1987-ой год) - функциональный язык программирования, основанный на языке программирования Prolog;
	\item Occam (Оксфордский университет - Великобритания; 1983-ий год) - процедурный язык параллельного программирования.

\end{itemize}

В настоящей лабораторной работе рассматривается язык программирования Erlang.

\mysubsubsection{Язык программирования Erlang}

Язык программирования Erlang \cite{erlang} суть функциональный язык программирования с динамической типизацией, позволяющий быстро и компактно\footnote{Имеется в виду минимизация объема исходного кода.} организовывать параллельные и распределенные вычисления. Erlang разработан и поддерживается компанией Ericsson.

Erlang относится к классу языков программирования, выполняющих программный код на собственной виртуальной машине. Исходный код программных модулей предварительно компилируется виртуальной машиной в байт-код, который ею и выполняется. Виртуальная машина Erlang'а оптимизирована для организации параллельных вычислений, что позволяет программисту, к примеру, запускать десятки тысяч вычислительных потоков на одной виртуальной машине без существенных потерь оперативной памяти на хранение различного рода служебной информации о потоках. Отличительными чертами Erlang'а от прочих языков программирования являются дешевая рекурсия и философия <<Let it crash>> (<<пусть падает>>), требующая от программиста выделять программный код, склонный к аварийным завершениям, в отдельный вычислительный поток, единственной реакцией на аварийное завершение которого должен быть его повторный запуск, если того требует логика программы.

\mysubsubsection{Виртуальная машина языка программирования Erlang}

Виртуальная машина языка программирования Erlang поддерживает два режима работы - интерактивный и неинтерактивный:

\begin{itemize}

	\item интерактивный режим работы.

	Интерактивный режим работы заключается в непосредственном вводе программистом инструкций на языке программирования Erlang.

	Для запуска виртуальной машины необходимо выполнить команду, приведенную в листинге \ref{listing:erlang:virt-start}.

\mylistingbegin{erlang:virt-start}{Запуск виртуальной машины}
\begin{lstlisting}

erl -name NAME@IP_ADDR

\end{lstlisting}
\mylistingend

	Здесь:
	
	\begin{itemize}
	
		\item NAME - имя вычислительного узла, ассоциируемого с запущенной копией виртуальной машины;
		\item IP\_ADDR - IPv4-адрес сетевого интерфейса вычислительной системы, подключения к одному из TCP-портов которого (как правило, порт 4369) виртуальная машина будет ожидать.

	\end{itemize}

	Ключ <<-name NAME@IP\_ADDR>> можно опустить - в этом случае виртуальная машина не будет доступна из-вне.

	Доступ к виртуальной машине из-вне означает, что другая (удаленная) виртуальная машина может подключится к данной и в фоновом режиме запустить на ней несколько вычислительных потоков. Для программиста нет серьезной разницы в том, где выполняется вычислительный поток - на виртуальной машине, оператором которой он является, или на удаленной виртуальной машине - единственное различие имеет место быть в параметрах, передаваемых функции spawn() при запуске потока.

	Виртуальные машины реализуют несколько способов идентификации и авторизации друг друга, простейшим (и принятым по умолчанию) из которых является способ, основанный на проверке совпадения строк - cookies:

	\begin{enumerate}

		\item оператор первой вычислительной системы входит в систему под именем некоторого пользователя;
		\item оператор первой вычислительной системы создает текстовый файл \$HOME/.erlang.cookie, состоящий из единственной строки, начинающейся с прописной буквы латинского алфавита и содержащей символы латинского алфавита, цифры и знак подчеркивания;
		\item оператор первой вычислительной системы запускает виртуальную машину языка программирования Erlang;
		\item оператор второй вычислительной системы входит в систему под именем некоторого пользователя;
		\item оператор второй вычислительной системы создает текстовый файл \$HOME/.erlang.cookie, состоящий из единственной строки, начинающейся с прописной буквы латинского алфавита и содержащей символы латинского алфавита, цифры и знак подчеркивания;
		\item оператор второй вычислительной системы запускает виртуальную машину языка программирования Erlang.

	\end{enumerate}

	Виртуальная машина, запущенная на первой вычислительной системе, будет успешно авторизована для запуска вычислительных потоков на виртуальной машине, запущенной на второй вычислительной системе, тогда и только тогда, когда первые строки файлов .erlang.cookie в домашних каталогах пользователей, запустивших виртуальные машины, будут совпадать.

	Для завершения работы виртуальной машины оператор должен:

	\begin{enumerate}

		\item нажать сочетание клавиш <<Ctrl + G>>;
		\item в ответ на приглашение <<User switch command>> нажать клавишу <<q>>;
		\item подтвердить необходимость завершения работы виртуальной машины нажатием клавиши <<Enter>>;

	\end{enumerate}

	\item неинтерактивный режим работы.

	Неинтерактивный режим работы заключается в написании программистом программного модуля с последующей компиляцией и запуском модуля на виртуальной машине.

	Исходный код программного модуля должен быть сохранен в файле с расширением .erl.
	
	Исходный код простого программного модуля приведен в листинге \ref{listing:erlang:simple-module}.

\mylistingbegin{erlang:simple-module}{Исходный код демонстрационного программного модуля}
\begin{lstlisting}

% Demo

-module(demo).
-import(math, [log / 1, sqrt / 1]).
-export([eval / 1]).

eval(X) -> sqrt(log(X)).

\end{lstlisting}
\mylistingend

	Здесь:

	\begin{itemize}

		\item символ \% отмечает начало строки - комментария; окончание комментария отмечает символ перехода на следующую строку;
		\item строка <<-module(demo).>> содержит название программного модуля (в рассматриваемом примере - demo); название программного модуля должно совпадать с именем файла, в котором сохранен исходный код модуля;
		\item строка <<-import(math, \verb|[|log / 1, sqrt / 1\verb|]|).>> суть есть предписание импортировать из программного модуля math (присутствует в стандартной библиотеке) функций log() и sqrt(), каждая из которых обладает одним параметром;
		\item строка <<-export(\verb|[|eval / 1\verb|]|).>> содержит перечисление функций программного модуля, которые будут доступны другим программным модулям после загрузки модуля demo в виртуальную машину (в данном случае будет доступна только функция eval(), обладающая одним параметром).

		Экспортируемыми должны быть также главные функции вычислительных потоков, запускаемых функционалом, реализованным в данном программном модуле;

		\item строка <<eval(X) -> sqrt(log(X)).>> содержит описание функции eval(), возвращающей квадратный корень из натурального логарифма значения своего единственного параметра (X).

	\end{itemize}

	После того, как исходный код программного модуля был сохранен в соответствующем файле (в рассматриваемом примере исходный код модуля demo должен быть сохранен в файле demo.erl), в каталоге, в котором находится файл с исходным кодом программного модуля, должна быть запущена виртуальная машина, которая выполнит компиляцию исходного кода программного модуля в байт-код, загрузку результата компиляции и запуск на выполнение одной из функций, экспортируемых программным модулем:

	\begin{itemize}

		\item компиляция исходного кода программного модуля в байт-код и, одновременно, загрузка в виртуальную машину результирующего байт-кода выполняется с помощью функции c() (в рассматриваемом примере - <<c(demo).>>).

		Результат компиляции исходного кода программного модуля в байт-код сохраняется в файле с расширением .beam (в рассматриваемом примере - demo.beam);

		\item загрузка в виртуальную машину байт-кода программного модуля из файла с расширением .beam выполняется с помощью функции nl() (в рассматриваемом примере функцию - <<nl(demo).>>).

	\end{itemize}

	В обоих случаях после загрузки в виртуальную машину байт-кода программного модуля, оператору виртуальной машины становятся доступными для вызова функции, экспортируемые программным модулем. Оператор виртуальной машины может вызвать любую функцию, экспортируемую модулем, с помощью оператора расширения пространства имен : (в рассматриваемом примере оператор может вызвать функцию eval(), экспортируемую модулем demo, с помощью инструкции <<demo:eval(NUM).>>, где NUM - некоторое целое или вещественное число).

	Необходимо помнить, что при организации параллельных и распределенных вычислений байт-код программного модуля должен быть загружен во всех виртуальных машинах, объединяемых в вычислительный кластер.

\end{itemize}

\mysubsubsection{Основные сведения о синтаксисе языка программирования Erlang}

Настоящий раздел является введением в язык программирования Erlang и поэтому не претендует на полноту его описания. Некоторые вопросы сознательно рассмотрены поверхностно или не рассмотрены вообще во избежание существенного усложнения материала. За дополнительными сведениями рекомендуем обратиться к \cite{erlang-doc} (официальная документация) или к \cite{erlang-rsdn} (неплохая статья для начинающих программистов на Erlang'е).

При написании программ на Erlang'е необходимо помнить, что данный язык программирования чувствителен к регистру букв.

\myparagraph{Объекты}

Система объектов Erlang'а обладает следующими особенностями:

\begin{itemize}

	\item создание объекта в Erlang'е происходит при присваивании ему инициализирующего значения; в Erlang'е нет специальных операторов объявления объектов;
	\item значение объекта невозможно изменить\footnote{С некоторым допущением переменные Erlang'а соответствуют именованным константам в языках программирования C и C++.};
	\item Erlang является языком программирования с динамической типизацией - тип объекта определяется по значению, которым он был инициализирован.

\end{itemize}

\begin{itemize}

	\item переменные.

		Имена переменных могут состоять из букв латинского алфавита, цифр и знака подчеркивания. Имя переменной должно начинаться с заглавной буквы.

		Erlang работает с данными следующих типов:

		\begin{itemize}

			\item целые числа произвольной длины;
			\item вещественные числа произвольной точности;
			\item идентификаторы процессов (PID);
			\item атомы;
			\item кортежи;
			\item списки;
			\item функции;
			\item прочие типы данных.

		\end{itemize}

		Числа в Erlang'е могут быть записаны в экспоненциальной нотации в системе счисления с основанием 10;

	\item атомы.

		Атом - именованная константа, имя которой является ее значением. Имена атомов подчиняются тем же требованиям, что и имена переменных, за исключением того, что имя атома должно начинаться со строчной буквы.

		Булев тип в Erlang'е реализуется на основе атомов - значение <<Истина>> суть есть атом true, значение <<Ложь>> - атом false;

	\item кортежи.

		Кортеж суть есть набор значений различных типов, сгруппированный с помощью фигурных скобок. Допускаются вложенные кортежи.

		Кортеж отличается от списка тем, что к нему нельзя применить функционал работы со списками (в частности, оператор декомпозиции списка).

		Пример объявления кортежа приведен в листинге \ref{listing:erlang:tuple:def}.
		
\mylistingbegin{erlang:tuple:def}{Объявление кортежа}
\begin{lstlisting}

Tuple = {1, 2, 3, {4.5, true}}.

\end{lstlisting}
\mylistingend

		В листинге \ref{listing:erlang:tuple:def} переменная Tuple инициализируется кортежем, состоящим из трех целых чисел и одного кортежа, который, в свою очередь, состоит из вещественного числа и атома true.

		Пример присвоения значений, собранных в кортеж, набору переменных приведен в листинге \ref{listing:erlang:tuple:set}.

\mylistingbegin{erlang:tuple:set}{Присвоение значений, собранных в кортеж, набору переменных}
\begin{lstlisting}

{A, B, C, {D, E}} = Tuple.

\end{lstlisting}
\mylistingend

		В листинге \ref{listing:erlang:tuple:set} каждое значение из кортежа Tuple и вложенного в него кортежа присваивается одной из следующих переменных: A, B, C, D, E;

	\item списки.

		Список суть есть набор произвольных значений. Список можно обработать с помощью специального функционала (оператор декомпозиции списка, оператор объединения списков, функционал модуля lists стандартной библиотеки, некоторые другие операторы и функции стандартной библиотеки). В отличии от массивов языков программирования C и C++ к элементу списка в Erlang'е нельзя получить доступ через индекс элемента.

		Инициализация списка выполняется путем перечисления в квадратных скобках значений, входящих в список. Пример инициализации списка приведен в листинге \ref{listing:erlang:list:create}.

\mylistingbegin{erlang:list:create}{Инициализация списка}
\begin{lstlisting}

L = [1, 2, 7.8, 2, -10, 5, 6, 7, 8, T].

\end{lstlisting}
\mylistingend

		В листинге \ref{listing:erlang:list:create} создается список L, состоящий из 10 значений (10-е значение - значение переменной T, объявленной ранее).

		Пустые квадратные скобки означают пустой список.

		Для создания списка из элементов другого списка можно использовать оператор ||, пример чего приведен в листинге \ref{listing:erlang:list:cp}.

\mylistingbegin{erlang:list:cp}{Создание нового списка с помощью оператора ||}
\begin{lstlisting}

NewL = [Q || Q <- L, Q > 2].

\end{lstlisting}
\mylistingend

		В листинге \ref{listing:erlang:list:cp} создается список NewL, который содержит все элементы списка L, значения которых больше двойки. Порядок элементов в списке NewL соответствует порядку элементов в списке L.

		Оператор декомпозиции списка | позволяет выделить из списка несколько значений, находящихся в его начале, а из прочих значений сформировать новый список с сохранением порядка. Примеры декомпозиции списка приведены в листинге \ref{listing:erlang:list:dec}.

\mylistingbegin{erlang:list:dec}{Декомпозиция списка}
\begin{lstlisting}

[ X | Tail ] = L.
[ Y, Z | TailTail] = Tail.

\end{lstlisting}
\mylistingend

\end{itemize}

		В первой строке листинга \ref{listing:erlang:list:dec} переменной X присваивается значение первого элемента списка L (коим является 1), <<хвост>> списка L копируется в список Tail. Во второй строке листинга \ref{listing:erlang:list:dec} переменным Y и Z присваиваются первое и второе значения списка Tail (то есть второе и третье значения списка L соответственно), содержимое списка Tail без его первого и второго элементов копируется в список TailTail.

		В Erlang'е присутствует оператор объединения списков - оператор ++. Данный оператор является бинарным и создает новый список, в начале которого расположены элементы списка - левого операнда, а в конце - элементы списка - правого операнда.

\myparagraph{Операторы}

\mysubparagraph{Арифметические, логические операторы, операторы отношений}

В таблице \ref{table:erlang:op} перечислены арифметические и логические операторы, а также операторы отношений, присутствующие в Erlang'е. В таблице \ref{table:erlang:op} предполагается, что нулевой приоритет - наивысший.

Для изменения приоритета операций допускается использовать круглые скобки.

\newcommand{\eophead}[1]
{
	\multicolumn{6}{r}{Таблица~\thetable~---~Операторы~языка~программирования~Erlang~(#1)} \\
	\hline
	\bf Оператор & \bf Тип & \bf Левый операнд & \bf Правый операнд & \bf Действие & \bf Приоритет \\
	\hline
}

\newcommand{\eop}[6]{#1 & #2 & #3 & #4 & #5 & #6 \\}
\newcommand{\eun}{Унарный\xspace}
\newcommand{\ein}{Бинарный\xspace}
\newcommand{\enum}{Число\xspace}
\newcommand{\enumZ}{Целое\xspace}
\newcommand{\efloat}{Вещественное\xspace}
\newcommand{\eool}{Булево значение\xspace}
\newcommand{\elist}{Список\xspace}
\newcommand{\efun}{Функция\xspace}
\newcommand{\eord}{Упорядоченное значение\xspace}

\begin{landscape}
\begin{longtable}[H]{|N|N|Z|Z|L|N|}

	\eophead{начало}
    \endfirsthead

	\eophead{окончание}
    \endlasthead
	
	\eophead{продолжение}
	\endhead

	\hline
	\endfoot

	\multicolumn{6}{|c|}{\bf Арифметические и логические операторы} \\
	
	\hline

	\label{table:erlang:op}
	\eop{}{\eun}{}{\enum}{Отрицание}{\multirow{3}{*}{0}}
	\eop{bnot}{\eun}{}{\enumZ}{Дополнение до двух}{}
	\eop{not}{\eun}{}{\eool}{Логическое отрицание}{}

	\hline

	\eop{/}{\ein}{\enum}{\enum}{Деление}{\multirow{6}{*}{1}}
	\eop{*}{\ein}{\enum}{\enum}{Умножение}{}
	\eop{div}{\ein}{\enumZ}{\enumZ}{Целочисленное деление}{}
	\eop{rem}{\ein}{\enumZ}{\enumZ}{Нахождение остатка от деления}{}
	\eop{band}{\ein}{\enumZ}{\enumZ}{Побитовое И}{}
	\eop{and}{\ein}{\eool}{\eool}{Логическое И}{}

	\hline

	\eop{+}{\ein}{\enum}{\enum}{Сложение}{\multirow{6}{*}{2}}
	\eop{}{\ein}{\enum}{\enum}{Вычитание}{}
	\eop{bor}{\ein}{\enumZ}{\enumZ}{Побитовое ИЛИ}{}
	\eop{bxor}{\ein}{\enumZ}{\enumZ}{Побитовое ИСКЛЮЧАЮЩЕЕ ИЛИ}{}
	\eop{or}{\ein}{\eool}{\eool}{Логическое ИЛИ}{}
	\eop{xor}{\ein}{\eool}{\eool}{Логическое ИСКЛЮЧАЮЩЕЕ ИЛИ}{}

	\hline

	\multicolumn{6}{|c|}{\bf Списковые операторы} \\

	\hline

	\eop{++}{\ein}{\elist}{\elist}{Объединение списков}{3}

	\hline

	\multicolumn{6}{|c|}{\bf Операторы отношений} \\

	\hline

	\eop{==}{\ein}{Упорядоченное значение (число, атом, список)}{\eord}{Равно}{\multirow{6}{*}{4}}
	\eop{/=}{\ein}{\eord}{\eord}{Не равно}{}
	\eop{=<}{\ein}{\eord}{\eord}{Меньше или равно}{}
	\eop{<}{\ein}{\eord}{\eord}{Меньше}{}
	\eop{>=}{\ein}{\eord}{\eord}{Больше или равно}{}
	\eop{>}{\ein}{\eord}{\eord}{Больше}{}

	\hline

	\multicolumn{6}{|c|}{\bf Оператор инициализации переменной} \\

	\hline

	\eop{=}{\ein}{Имя переменной}{Значение}{Инициализация переменной}{5}

\end{longtable}
\end{landscape}

\mysubparagraph{Условные операторы}

Язык программирования Erlang содержит следующие условные операторы:

\begin{itemize}

	\item условный оператор if ... end.

		Синтаксис оператора if ... end приведен в листинге \ref{listing:erlang:if}.

\mylistingbegin{erlang:if}{Условный оператор if ... end}
\begin{lstlisting}

if
	
	CONDITION_1 ->

		OPERATOR_1_1,
		OPERATOR_1_2,
		...,
		OPERATOR_1_N;

	CONDITION_2 ->

		OPERATOR_2_1,
		OPERATOR_2_2,
		...,
		OPERATOR_2_M;

	...

	true ->

		OPERATOR_1,
		OPERATOR_2,
		...,
		OPERATOR_L

end.

\end{lstlisting}
\mylistingend

		Оператор if ... end последовательно проверяет условия (CONDITION\_1, CONDITION\_2, ..., \_) до тех пор, пока одно из условий не окажется истинным. Для истинного условия выполняется соответствующая последовательность операторов, результат выполнения последнего из которых (OPERATOR\_1\_N, OPERATOR\_2\_M или OPERATOR\_L) возвращается оператором if ... end в выполняющую его функцию (таким образом, оператор if ... end можно использовать при инициализации переменных).

		Условие true всегда истинно. Условие true и соответствующая ему последовательность операторов могут быть опущены - в этом случае оператор if ... end, проверив все условия и не найдя среди них верного, возбудит исключительную ситуацию, в случае необработки которой поток, выполнявший оператор if ... end, будет завершен.

		Необходимо помнить, что перед ключевым словом end точка с запятой никогда не ставится;

	\item условный оператор case ... end.

		Синтаксис условного оператора case ... end приведен в листинге \ref{listing:erlang:case}.

\mylistingbegin{erlang:case}{Условный оператор case ... end}
\begin{lstlisting}

case EXPRESSION of

	PATTERN_1 ->

		OPERATOR_1_1,
		OPERATOR_1_2,
		...,
		OPERATOR_1_N;

	PATTERN_2 ->

		OPERATOR_2_1,
		OPERATOR_2_2,
		...,
		OPERATOR_2_M;

	...

	_ ->

		OPERATOR_1,
		OPERATOR_2,
		...,
		OPERATOR_L

end.

\end{lstlisting}
\mylistingend

		Оператор case ... end последовательно сопоставляет значение выражения EXPRESSION с каждым из шаблонов (PATTERN\_1, PATTERN\_2, ,.., \_) до тех пор, пока сопоставление не окажется успешным. Как только будет найдено успешное сопоставление, выполняется соответствующая последовательность операторов, результат последнего из которых (OPERATOR\_1\_N, OPERATOR\_2\_M или OPERATOR\_L) возвращается оператором case ... end в выполнящую его функцию.

		Шаблон \_ дает (с некоторым, простительным для данного вводного руководства, допущением) всегда истинное сопоставление. Шаблон \_ может быть опущен, что может привести к последствиям, сходным с теми, которые имеют место быть при пропуске условия true при использовании оператора if ... end.

		Шаблон суть есть некоторое значение, с которым сопоставляется переменная. В случае списка этим значением может быть оператор декомпозиции списка, тогда, если переменная является списком, шаблон вернет верное сопоставление и выполнит декомпозицию списка.

		Пример использования оператора case ... end приведен в листинге \ref{listing:erlang:case:example}.

\mylistingbegin{erlang:case:example}{Пример использования оператора case ... end}
\begin{lstlisting}

eval(X) ->

	Y = case X of

			10 ->

				20;

			20 ->

				Z = math:log(20),
				Z * 2;

			[Z | _] ->

				Z * 2;

			_ ->

				-1

		end,

	math:sin(Y).

\end{lstlisting}
\mylistingend

		В листинге \ref{listing:erlang:case:example} объявлена функция eval(), принимающая единственный параметр X. Данная функция:

		\begin{enumerate}

			\item инициализирует переменную Y, присваивая той одно из следующих значений:

			\begin{itemize}

				\item 20, если X равно 10;
				\item $2\ln(20)$, если X равно 20;
				\item удвоенное значение первого элемента списка X, если X является списком.

					В декомпозиции списка \verb|[|Z | \_\verb|]| символ подчеркивания означает игнорирование <<хвоста>> списка X;

				\item -1 во всех остальных случаях;

			\end{itemize}

			\item возвращает в вызывающую функцию $\sin(\text{Y})$.

		\end{enumerate}

\end{itemize}

\myparagraph{Функции}

Любая подпрограмма в Erlang'е суть есть функция - то есть любая подпрограмма в Erlang'е возвращает в вызывающую ее подпрограмму определенное значение определенного типа после определенных операций над своими параметрами.

Синтаксис описания функции приведен в листинге \ref{listing:erlang:fun}.

\mylistingbegin{erlang:fun}{Описание функции}
\begin{lstlisting}

function(PATTERN_1) ->

	OPERATOR_1,
	OPERATOR_2,
	...
	OPERATOR_N;

function(PATTERN_2) when CONDITION ->

	OPERATOR_N_1,
	OPERATOR_N_2,
	...
	OPERATOR_N_M;

...

function(PATTERN_Q) ->

	OPERATOR_N_M_1,
	OPERATOR_N_M_2,
	...
	OPERATOR_N_M_L.

\end{lstlisting}
\mylistingend

В листинге \ref{listing:erlang:fun} содержится объявление функции с именем function. В Erlang'е допускается перегрузка функций - каждая функция в Erlang'е идентифицируется по имени и количеству параметров. Имена функций в Erlang'е подчиняются тем же требованиям, что и имена атомов.

Функция function() выполняет следущую последовательность действий:

\begin{enumerate}

	\item проверяет совпадение переданного ей набора фактических параметров с шаблоном PATTERN\_1. Если шаблон и набор фактических параметров совпадают, то функция выполняет последовательность операторов OPERATOR\_1, OPERATOR\_2, ..., OPERATOR\_N, возвращая значение последнего оператора (OPERATOR\_N) в вызывающую ее функцию;

	\item если набор фактических параметров не совпал с шаблоном PATTERN\_1, то Erlang проверяет совпадение набора фактических параметров со следующим шаблоном (PATTERN\_2), при этом последовательность операторов OPERATOR\_N\_1, OPERATOR\_N\_2, ..., OPERATOR\_N\_M будет выполнена только в том случае, если набор фактических параметров совпадет с шаблоном PATTERN\_2 и будет выполнено условие CONDITION;

	\item проверка совпадения набора фактических параметров с шаблонами продолжается до тех пор, пока совпадение не будет найдено. Как только совпадение будет найдено - будет выполнена соответствующая последовательность операторов. Если же совпадения найти не удасться, то функция возбудит исключительную ситуацию, без должной обработки которой вычислительный поток, выполняющий функцию, завершит свое выполнение.

\end{enumerate}

Функция должна состоять как минимум из одного блока сопоставления набора своих параметров с шаблоном и соответствующей последовательности операторов.

В шаблонах допускается использовать имена переменных - в этом случае внутри функции переменной с именем, использованным в шаблоне, будет присвоено соответствующее значение из набора фактических параметров.

Элементы шаблона, соответствующие параметрам, должны быть перечислены через запятую.

Синтаксис вызова функции приведен в листинге \ref{listing:erlang:fun:call}.

\mylistingbegin{erlang:fun:call}{Вызов функции}
\begin{lstlisting}

function(PAR_1, PAR_2, ..., PAR_R).

\end{lstlisting}
\mylistingend

В листинге \ref{listing:erlang:fun:call} содержится вызов функции function() с набором фактических значений ее параметров - PAR\_1, PAR\_2, ..., PAR\_R.

Пример описания функции приведен в листинге \ref{listing:erlang:fun:ex:def}, примеры вызова функции pow() из листинга \ref{listing:erlang:fun:ex:def} приведены в листинге \ref{listing:erlang:fun:ex:call}.

\mylistingbegin{erlang:fun:ex:def}{Пример описания функции}
\begin{lstlisting}

pow(_, 0) ->

	1;

pow(X, S) when ((S > 10) or (S < 0) or (X == 0) and (S == 0)) ->

	-1;

pow(X, S) ->

	X * pow(X, S - 1).

\end{lstlisting}
\mylistingend

\mylistingbegin{erlang:fun:ex:call}{Примеры вызова функции}
\begin{lstlisting}

A = pow(55, 3).
B = pow(77, 0).
C = pow(111, -1).
D = pow(777, 11).
E = pow(0, 0).

\end{lstlisting}
\mylistingend

В листинге \ref{listing:erlang:fun:ex:def} описывается функция pow(), имеющая два параметра. Функция pow() возводит первый параметр в целочисленную степень, переданную во втором параметре. Функция pow() работает со значениями своего второго параметра из диапазона $[0 ;~ 10]$, прочие же значения своего второго параметра и ситуацию, при которой оба параметра функции pow() принимают нулевое значение, функция pow() рассматривает как некорректные и возвращает -1.

Для организации вычисления целочисленной степени своего первого параметра функция pow() использует метод хвостовой рекурсии - один из возможных способов замены циклов в Erlang'е. Другой распространенный способ замены циклов - использование свертки списков.

Переменные A, B, C, D, E в листинге \ref{listing:erlang:fun:ex:call} инициализируются следующими значениями:

\begin{itemize}

	\item $\text{A} = 55^3$;
	\item $\text{B} = 1$;
	\item $\text{C} = \text{D} = \text{E} = -1$.

\end{itemize}

\mysubparagraph{$\lambda$-выражения}

Каждая функция в Erlang'е суть есть переменная, тип данных которой - функция. Функции, таким образом, можно передавать как параметр в другие функции; возможно составление списков функций.

Одним из удобных способов описания функций в Erlang'е является использование ключевого слова fun. С помощью ключевого слова fun функцию можно описать непосредственно в инструкции инициализации некоторой переменной - таковое описание функций называют также $\lambda$-выражением.

Синтаксис $\lambda$-выражения приведен в листинге \ref{listing:erlang:lambda}.

\mylistingbegin{erlang:lambda}{$\lambda$-выражение}
\begin{lstlisting}

VARIABLE = fun(PAR_1, PAR_2, ..., PAR_N) -> EXPRESSION end.

\end{lstlisting}
\mylistingend

В листинге \ref{listing:erlang:lambda} переменной VARIABLE присваивается значение типа <<функция>>. Функция VARIABLE обладает параметрами PAR\_1, PAR\_2, ..., PAR\_N и возвращает значение выражения EXPRESSION.

Пример использования ключевого слова fun приведен в листинге \ref{listing:erlang:lambda:ex}.

\mylistingbegin{erlang:lambda:ex}{Пример использования ключевого слова fun}
\begin{lstlisting}

A = fun(X) -> X * 2 end.
B = A(10).
C = A(20).

\end{lstlisting}
\mylistingend

В первой строке листинга \ref{listing:erlang:lambda:ex} описывается функция, возвращающая значение своего параметра, умноженное на два. Значения переменных B и C равны 20-и и 40-а после выполнения второй и третьей строк листинга соответственно.

\myparagraph{Стандартная библиотека}

Erlang обладает обширной стандартной библиотекой функций.

Программист в разрабатываемом им программном модуле может вызвать функцию из стандартной библиотеки одним из следующих способов:

\begin{itemize}

	\item определив список функций, импортируемых из целевого модуля стандартной библиотеки, с помощью диррективы import, как это было сделано в листинге \ref{listing:erlang:simple-module};
	\item вызвать функцию с помощью оператора расширения пространства имен :~.

\end{itemize}

Информация о некоторых функциях из стандартной библиотеки сведена в таблицу \ref{table:erlang:fun}.

\newcommand{\elhead}[1]
{
	\multicolumn{6}{r}{Таблица~\thetable~---~Некоторые функции стандартной библиотеки~(#1)} \\
	\hline
	\multirow{2}{*}{\bf Функция} & \multicolumn{3}{c|}{\bf Параметры} & \multirow{2}{*}{\vbox{\centering \bf Возвращаемое \\ значение}} & \multirow{2}{*}{\bf Примечание} \\
	\cline{2-4}
	& \bf 1 & \bf 2 & \bf 3 && \\
	\hline
}

\newcommand{\elf}[6]{#1 & #2 & #3 & #4 & #5 & #6 \\}

\begin{landscape}
\begin{longtable}[H]{|U|U|U|U|P|V|}

	\elhead{начало}
    \endfirsthead

	\elhead{окончание}
    \endlasthead
	
	\elhead{продолжение}
	\endhead

	\hline
	\endfoot

	\multicolumn{6}{|c|}{\bf Генерация псевдослучайных чисел (модуль random)} \\
	
	\hline

	\label{table:erlang:fun}
	\elf{seed}{}{}{}{Состояние датчика}{Инициализирует датчик псевдослучайных чисел}
	\elf{uniform}{}{}{}{\efloat}{Генерирует реализацию псевдослучайной величины, равномерно распределенной на диапазоне $[0 ;~ 1]$}
	\elf{uniform}{\enumZ (N)}{}{}{\enumZ}{Генерирует реализацию псевдослучайной величины, равномерно распределенной на диапазоне $[0 ;~ N]$}

	\hline

	\multicolumn{6}{|c|}{\bf Математические операции (модуль math)} \\

	\hline

	\elf{pi}{}{}{}{\efloat}{$\pi$}
	\elf{sin}{\enum}{}{}{\enum}{}
	\elf{cos}{\enum}{}{}{\enum}{}
	\elf{tan}{\enum}{}{}{\enum}{}
	\elf{asin}{\enum}{}{}{\enum}{}
	\elf{acos}{\enum}{}{}{\enum}{}
	\elf{atan}{\enum}{}{}{\enum}{}
	\elf{sinh}{\enum}{}{}{\enum}{}
	\elf{cosh}{\enum}{}{}{\enum}{}
	\elf{tanh}{\enum}{}{}{\enum}{}
	\elf{asinh}{\enum}{}{}{\enum}{}
	\elf{acosh}{\enum}{}{}{\enum}{}
	\elf{atanh}{\enum}{}{}{\enum}{}
	\elf{exp}{\enum}{}{}{\enum}{}
	\elf{log}{\enum (X)}{}{}{\enum}{$\ln(X)$}
	\elf{log10}{\enum (X)}{}{}{\enum}{$\lg(X)$}
	\elf{pow}{\enum (X)}{\enum (Y)}{}{\enum}{$X^Y$}
	\elf{sqrt}{\enum (X)}{}{}{\enum}{$\sqrt{X}$}

	\hline

	\multicolumn{6}{|c|}{\bf Операции над списками (модуль lists)} \\

	\hline

	\elf{delete}{EXPR}{\elist}{}{\elist}{Удаляет из списка крайний левый элемент, значение которого равно значению выражения EXPR}
	\elf{filter}{\efun}{\elist}{}{\elist}{Удаляет из списка все элементы, для которых функция не возвращает атом true}
	\elf{foldl}{\efun}{\enum}{\elist}{\enum}{Последовательно вызывает функцию для каждого элемента списка, передавая элемент списка первым параметром в функцию, а результат предыдущего вызова функции - вторым параметром (для первого элемента списка - значение второго параметра функции foldl()). Результат последнего вызова возвращается функцией foldl().}
	\elf{foldr}{\efun}{\enum}{\elist}{\enum}{То же, что и foldl(), только направление обхода списка - справа налево}
	\elf{foreach}{\efun}{\elist}{}{ok}{Для каждого элемента списка вызывается функция со значением элемента списка в качестве единственного параметра}
	\elf{last}{\elist}{}{}{Элемент списка}{Возвращает последний элемент списка}
	\elf{map}{\efun}{\elist}{}{\elist}{Возвращает список, каждый элемент которого является результатом выполнения функции для значения соответствующего элемента исходного списка}
	\elf{max}{\elist}{}{}{Элемент списка}{Возвращает максимальное значение из значений элементов списка}
	\elf{min}{\elist}{}{}{Элемент списка}{Возвращает минимальное значение из значений элементов списка}
	\elf{seq}{\enumZ}{\enumZ}{}{\elist}{Возвращает список, состоящий из последовательности целых чисел от значения первого параметра до значения второго параметра включительно с шагом 1}
	\elf{seq}{\enumZ}{\enumZ}{\enumZ}{\elist}{Возвращает список, состоящий из последовательности целых чисел от значения первого параметра до значения второго параметра включительно с шагом равным значению третьего параметра}
	\elf{sort}{\elist}{}{}{\elist}{Сортирует список}
	\elf{sort}{\efun}{\elist}{}{\elist}{Сортирует список в соответствии с порядком, описываемым функцией. Функция возвращает атом true, если значение ее первого параметра меньше или равно значению ее второго параметра и false в противном случае.}
	\elf{split}{\enumZ}{\elist}{}{\{~\elist, \elist~\}}{Разбивает список на два списка, помещая в первый список указанное первым параметром число первых элементов исходного списка, во второй список - все остальные элементы исходного списка}
	\elf{sum}{\elist}{}{}{\enum}{Вычисляет сумму значений элементов списка}

\end{longtable}
\end{landscape}

\mysubsubsection{Параллельное программирование с помощью языка программирования Erlang}

Erlang реализует модель параллельных вычислений с взаимодействием вычислительных потоков путем обмена сообщениями. Мы будем придерживаться терминологии официальной документации Erlang'а и называть вычислительные потоки процессами.

Процесс в Erlang'е может быть запущен с помощью функции spawn(), имеющей следующие параметры:

\begin{enumerate}

	\item строка с именем виртуальной машины, на которой необходимо запустить процесс, и IP-адресом вычислительного узла, на котором данная виртуальная машина запущена.

	Данный параметр может быть опущен, если требуется запустить процесс на виртуальной машине, исполняющей запускающий процесс;

	\item имя модуля, экспортирующего главную функцию запускаемого процесса;

	\item имя главной функции запускаемого процесса.

	Данная функция будет запущена сразу после создания нового процесса и процесс завершится по возврату из данной функции;

	\item список фактических значений параметров главной функции запускаемого процесса.

\end{enumerate}

Функция spawn() возвращает PID запущенного процесса. Процесс может получить свой PID, вызвав функцию self().

Оператор ! используется для отправления сообщения целевому процессу. Оператор ! является бинарным - его левый операнд суть есть PID процесса - получателя сообщения, правый операнд - отправляемое сообщение (значение произвольного типа).

Каждый процесс обладает очередью сообщений, сообщения из которой он может выбирать с помощью оператора receive ... end. Если очередь сообщений пуста, то оператор receive ... end заблокирует процесс до поступления туда сообщений, интересующих процесс.

Синтаксис оператора receive ... end приведен в листинге \ref{listing:erlang:receive}.

\mylistingbegin{erlang:receive}{Оператор receive ... end}
\begin{lstlisting}

receive

	PATTERN_1 ->

		OPERATOR_1_1,
		OPERATOR_1_2,
		...,
		OPERATOR_1_N;

	PATTERN_2 ->

		OPERATOR_N_1,
		OPERATOR_N_2,
		...,
		OPERATOR_N_M;

	...

	_ ->

		OPERATOR_N_M_1,
		OPERATOR_N_M_2,
		...,
		OPERATOR_N_M_L

end.

\end{lstlisting}
\mylistingend

Поведение оператора receive ... end совпадает с поведением оператора case ... end с той лишь разницей, что оператор receive ... end последовательно сопоставляет с набром шаблонов каждое сообщение очереди сообщений процесса в порядке их поступления или блокирует процесс до поступления сообщения, которое бы удовлетворило хотя бы одному шаблону.

