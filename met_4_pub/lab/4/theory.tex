
\mysubsubsection{Введение}

Упрощения процесса организации эффективных параллельных и распределенных вычислений, требуется язык программирования, изначально спроектированный для организации таковых вычислений - то есть язык параллельного программирования.

На настоящий момент наибольшей популярностью пользуются следующие языки параллельного программирования:

\begin{itemize}

	\item Alice (Саарский университет - Германия; 2002-ой год) - функциональный язык программирования, один из диалектов языка программирования Standart ML;
	\item Cilk, Cilk++ (Intel, ранее Cilk Arts - США; 1994 год) , T++ (Институт программных систем РАН; 80-е года XX-го века) - языки параллельного программирования, основанные на языках программирования C и C++;
	\item Erlang (Ericsson Computer Science Laboratory - Швеция; 1987-ой год) - функциональный язык программирования, основанный на языке программирования Prolog;
	\item Occam (Оксфордский университет - Великобритания; 1983-ий год) - процедурный язык параллельного программирования.

\end{itemize}

В настоящей лабораторной работе рассматривается язык программирования Erlang.

\mysubsubsection{Язык программирования Erlang}

Язык программирования Erlang \cite{erlang} суть функциональный язык программирования с динамической типизацией, позволяющий быстро и компактно\footnote{Имеется в виду минимизация объема исходного кода.} организовывать параллельные и распределенные вычисления. Erlang разработан и поддерживается компанией \linebreak Ericsson.

Erlang относится к классу языков программирования, выполняющих программный код на собственной виртуальной машине. Исходный код программных модулей предварительно компилируется виртуальной машиной в байт-код, который ею и выполняется. Виртуальная машина Erlang'а оптимизирована для организации параллельных вычислений, что позволяет программисту, к примеру, запускать десятки тысяч вычислительных потоков на одной виртуальной машине без существенных потерь оперативной памяти на хранение различного рода служебной информации о потоках. Отличительными чертами Erlang'а от прочих языков программирования являются дешевая рекурсия и философия <<Let it crash>> (<<пусть падает>>), требующая от программиста выделять программный код, склонный к аварийным завершениям, в отдельный вычислительный поток, единственной реакцией на аварийное завершение которого должен быть его повторный запуск, если того требует логика программы.

\mysubsubsection{Виртуальная машина языка программирования Erlang}

Виртуальная машина языка программирования Erlang поддерживает два режима работы - интерактивный и неинтерактивный:

\begin{itemize}

	\item интерактивный режим работы.

	Интерактивный режим работы заключается в непосредственном вводе программистом инструкций на языке программирования Erlang.

	Для запуска виртуальной машины необходимо выполнить команду, приведенную в листинге \ref{listing:erlang:virt-start}.

\mylistingbegin{erlang:virt-start}{Запуск виртуальной машины}
\begin{lstlisting}

erl -name NAME@IP_ADDR

\end{lstlisting}
\mylistingend

	Здесь:
	
	\begin{itemize}
	
		\item NAME - имя вычислительного узла, ассоциируемого с запущенной копией виртуальной машины;
		\item IP\_ADDR - IPv4-адрес сетевого интерфейса вычислительной системы, подключения к одному из TCP-портов которого (как правило, порт 4369) виртуальная машина будет ожидать.

	\end{itemize}

	Ключ <<-name NAME@IP\_ADDR>> можно опустить - в этом случае виртуальная машина не будет доступна из-вне.

	Доступ к виртуальной машине из-вне означает, что другая (удаленная) виртуальная машина может подключится к данной и в фоновом режиме запустить на ней несколько вычислительных потоков. Для программиста нет серьезной разницы в том, где выполняется вычислительный поток - на виртуальной машине, оператором которой он является, или на удаленной виртуальной машине - единственное различие имеет место быть в параметрах, передаваемых функции spawn() при запуске потока.

	Виртуальные машины реализуют несколько способов идентификации и авторизации друг друга, простейшим (и принятым по умолчанию) из которых является способ, основанный на проверке совпадения строк - cookies:

	\begin{enumerate}

		\item оператор первой вычислительной системы входит в систему под именем некоторого пользователя;
		\item оператор первой вычислительной системы создает текстовый файл \$HOME/.erlang.cookie, состоящий из единственной строки, начинающейся с прописной буквы латинского алфавита и содержащей символы латинского алфавита, цифры и знак подчеркивания;
		\item оператор первой вычислительной системы запускает виртуальную машину языка программирования Erlang;
		\item оператор второй вычислительной системы входит в систему под именем некоторого пользователя;
		\item оператор второй вычислительной системы создает текстовый файл \$HOME/.erlang.cookie, состоящий из единственной строки, начинающейся с прописной буквы латинского алфавита и содержащей символы латинского алфавита, цифры и знак подчеркивания;
		\item оператор второй вычислительной системы запускает виртуальную машину языка программирования Erlang.

	\end{enumerate}

	Виртуальная машина, запущенная на первой вычислительной системе, будет успешно авторизована для запуска вычислительных потоков на виртуальной машине, запущенной на второй вычислительной системе, тогда и только тогда, когда первые строки файлов .erlang.cookie в домашних каталогах пользователей, запустивших виртуальные машины, будут совпадать.

	Для завершения работы виртуальной машины оператор должен:

	\begin{enumerate}

		\item нажать сочетание клавиш <<Ctrl + G>>;
		\item в ответ на приглашение <<User switch command>> нажать клавишу <<q>>;
		\item подтвердить необходимость завершения работы виртуальной машины нажатием клавиши <<Enter>>;

	\end{enumerate}

	\item неинтерактивный режим работы.

	Неинтерактивный режим работы заключается в написании программистом программного модуля с последующей компиляцией и запуском модуля на виртуальной машине.

	Исходный код программного модуля должен быть сохранен в файле с расширением .erl.
	
	Исходный код простого программного модуля приведен в листинге \ref{listing:erlang:simple-module}.

\mylistingbegin{erlang:simple-module}{Исходный код демонстрационного программного модуля}
\begin{lstlisting}

% Demo

-module(demo).
-import(math, [log / 1, sqrt / 1]).
-export([eval / 1]).

eval(X) -> sqrt(log(X)).

\end{lstlisting}
\mylistingend

	Здесь:

	\begin{itemize}

		\item символ \% отмечает начало строки - комментария; окончание комментария отмечает символ перехода на следующую строку;
		\item строка <<-module(demo).>> содержит название программного модуля (в рассматриваемом примере - demo); название программного модуля должно совпадать с именем файла, в котором сохранен исходный код модуля;
		\item строка <<-import(math, \verb|[|log / 1, sqrt / 1\verb|]|).>> суть есть предписание импортировать из программного модуля math (присутствует в стандартной библиотеке) функций log() и sqrt(), каждая из которых обладает одним параметром;
		\item строка <<-export(\verb|[|eval / 1\verb|]|).>> содержит перечисление функций программного модуля, которые будут доступны другим программным модулям после загрузки модуля demo в виртуальную машину (в данном случае будет доступна только функция eval(), обладающая одним параметром).

		Экспортируемыми должны быть также главные функции вычислительных потоков, запускаемых функционалом, реализованным в данном программном модуле;

		\item строка <<eval(X) -> sqrt(log(X)).>> содержит описание функции eval(), возвращающей квадратный корень из натурального логарифма значения своего единственного параметра (X).

	\end{itemize}

	После того, как исходный код программного модуля был сохранен в соответствующем файле (в рассматриваемом примере исходный код модуля demo должен быть сохранен в файле demo.erl), в каталоге, в котором находится файл с исходным кодом программного модуля, должна быть запущена виртуальная машина, которая выполнит компиляцию исходного кода программного модуля в байт-код, загрузку результата компиляции и запуск на выполнение одной из функций, экспортируемых программным модулем:

	\begin{itemize}

		\item компиляция исходного кода программного модуля в байт-код и, одновременно, загрузка в виртуальную машину результирующего байт-кода выполняется с помощью функции c() (в рассматриваемом примере - <<c(demo).>>).

		Результат компиляции исходного кода программного модуля в байт-код сохраняется в файле с расширением .beam (в рассматриваемом примере - demo.beam);

		\item загрузка в виртуальную машину байт-кода программного модуля из файла с расширением .beam выполняется с помощью функции nl() (в рассматриваемом примере функцию - <<nl(demo).>>).

	\end{itemize}

	В обоих случаях после загрузки в виртуальную машину байт-кода программного модуля, оператору виртуальной машины становятся доступными для вызова функции, экспортируемые программным модулем. Оператор виртуальной машины может вызвать любую функцию, экспортируемую модулем, с помощью оператора расширения пространства имен : (в рассматриваемом примере оператор может вызвать функцию eval(), экспортируемую модулем demo, с помощью инструкции <<demo:eval(NUM).>>, где NUM - некоторое целое или вещественное число).

	Необходимо помнить, что при организации параллельных и распределенных вычислений байт-код программного модуля должен быть загружен во всех виртуальных машинах, объединяемых в вычислительный кластер.

\end{itemize}

\mysubsubsection{Основные сведения о синтаксисе языка программирования Erlang}

Настоящий раздел является введением в язык программирования Erlang и поэтому не претендует на полноту его описания. За дополнительными сведениями рекомендуем обратиться к \cite{erlang-doc} (официальная документация) или к \cite{erlang-rsdn} (неплохая статья для начинающих программистов на Erlang'е).

При написании программ на Erlang'е необходимо помнить, что данный язык программирования чувствителен к регистру символов.

\myparagraph{Объекты}

Система объектов Erlang'а обладает следующими особенностями:

\begin{itemize}

	\item создание объекта в Erlang'е происходит при присваивании ему инициализирующего значения; в Erlang'е нет специальных операторов объявления объектов;
	\item значение объекта невозможно изменить\footnote{С некоторым допущением переменные Erlang'а соответствуют именованным константам в языках программирования C и C++.};
	\item Erlang является языком программирования с динамической типизацией - тип объекта определяется по значению, которым он был инициализирован.

\end{itemize}

\begin{itemize}

	\item переменные.

		Имена переменных могут состоять из букв латинского алфавита, цифр и знака подчеркивания. Имя переменной должно начинаться с заглавной буквы.

		Erlang работает с данными следующих типов:

		\begin{itemize}

			\item целые числа произвольной длины;
			\item вещественные числа произвольной точности;
			\item идентификаторы процессов (PID);
			\item атомы;
			\item кортежи;
			\item списки;
			\item функции;
			\item прочие типы данных.

		\end{itemize}

		Числа в Erlang'е могут быть записаны в экспоненциальной нотации в системе счисления с основанием 10;

	\item атомы.

		Атом - именованная константа, имя которой является ее значением. Имена атомов подчиняются тем же требованиям, что и имена переменных, за исключением того, что имя атома должно начинаться со строчной буквы.

		Булев тип в Erlang'е реализуется на основе атомов - значение <<Истина>> суть есть атом true, значение <<Ложь>> - атом false;

	\item кортежи.

		Кортеж суть есть набор значений различных типов, сгруппированный с помощью фигурных скобок. Допускаются вложенные кортежи.

		Кортеж отличается от списка тем, что к нему нельзя применить функционал работы со списками (в частности, оператор декомпозиции списка).

		Пример объявления кортежа приведен в листинге \ref{listing:erlang:tuple:def}.
		
\mylistingbegin{erlang:tuple:def}{Объявление кортежа}
\begin{lstlisting}

Tuple = {1, 2, 3, {4.5, true}}.

\end{lstlisting}
\mylistingend

		В листинге \ref{listing:erlang:tuple:def} переменная Tuple инициализируется кортежем, состоящим из трех целых чисел и одного кортежа, который, в свою очередь, состоит из вещественного числа и атома true.

		Пример присвоения значений, собранных в кортеж, набору переменных приведен в листинге \ref{listing:erlang:tuple:set}.

\mylistingbegin{erlang:tuple:set}{Присвоение значений, собранных в кортеж, набору переменных}
\begin{lstlisting}

{A, B, C, {D, E}} = Tuple.

\end{lstlisting}
\mylistingend

		В листинге \ref{listing:erlang:tuple:set} каждое значение из кортежа Tuple и вложенного в него кортежа присваивается одной из следующих переменных: A, B, C, D, E;

	\item списки.

		Список суть есть набор произвольных значений. Список можно обработать с помощью специального функционала (оператор декомпозиции списка, оператор объединения списков, функционал модуля lists стандартной библиотеки, некоторые другие операторы и функции стандартной библиотеки). В отличии от массивов языков программирования C и C++ к элементу списка в Erlang'е нельзя получить доступ через индекс элемента.

		Инициализация списка выполняется путем перечисления в квадратных скобках значений, входящих в список. Пример инициализации списка приведен в листинге \ref{listing:erlang:list:create}.

\mylistingbegin{erlang:list:create}{Инициализация списка}
\begin{lstlisting}

L = [1, 2, 7.8, 2, -10, 5, 6, 7, 8, T].

\end{lstlisting}
\mylistingend

		В листинге \ref{listing:erlang:list:create} создается список L, состоящий из 10 значений (10-е значение - значение переменной T, объявленной ранее).

		Пустые квадратные скобки означают пустой список.

		Для создания списка из элементов другого списка можно использовать оператор ||, пример чего приведен в листинге \ref{listing:erlang:list:cp}.

\mylistingbegin{erlang:list:cp}{Создание нового списка с помощью оператора ||}
\begin{lstlisting}

NewL = [Q || Q <- L, Q > 2].

\end{lstlisting}
\mylistingend

		В листинге \ref{listing:erlang:list:cp} создается список NewL, который содержит все элементы списка L, значения которых больше двойки. Порядок элементов в списке NewL соответствует порядку элементов в списке L.

		Оператор декомпозиции списка | позволяет выделить из списка несколько значений, находящихся в его начале, а из прочих значений сформировать новый список с сохранением порядка. Примеры декомпозиции списка приведены в листинге \ref{listing:erlang:list:dec}.

\mylistingbegin{erlang:list:dec}{Декомпозиция списка}
\begin{lstlisting}

[ X | Tail ] = L.
[ Y, Z | TailTail] = Tail.

\end{lstlisting}
\mylistingend

\end{itemize}

		В первой строке листинга \ref{listing:erlang:list:dec} переменной X присваивается значение первого элемента списка L (коим является 1), <<хвост>> списка L копируется в список Tail. Во второй строке листинга \ref{listing:erlang:list:dec} переменным Y и Z присваиваются первое и второе значения списка Tail (то есть второе и третье значения списка L соответственно), содержимое списка Tail без его первого и второго элементов копируется в список TailTail.

		В Erlang'е присутствует оператор объединения списков - оператор ++. Данный оператор является бинарным и создает новый список, в начале которого расположены элементы списка - левого операнда, а в конце - элементы списка - правого операнда.

\myparagraph{Операторы}

\mysubparagraph{Арифметические, логические операторы, операторы отношений}

В таблице \ref{table:erlang:op} перечислены арифметические и логические операторы, а также операторы отношений, присутствующие в Erlang'е. В таблице \ref{table:erlang:op} предполагается, что нулевой приоритет - наивысший.

Для изменения приоритета операций допускается использовать круглые скобки.

\input{lab/4/operator}

\mysubparagraph{Условные операторы}

Язык программирования Erlang содержит условные операторы if и case. Синтаксис оператора if ... end приведен в листинге \ref{listing:erlang:if}.

\mylistingbegin{erlang:if}{Условный оператор if ... end}
\begin{lstlisting}

if
	
	COND_1 ->

		OP_1,
		...,
		OP_N;

	...

	true ->

		...

end.

\end{lstlisting}
\mylistingend

Оператор if ... end последовательно проверяет условия (COND\_1, ..., true) до тех пор, пока одно из условий не окажется истинным. Для истинного условия выполняется соответствующая последовательность операторов, результат выполнения последнего из которых возвращается оператором if ... end в выполняющую его функцию (таким образом, оператор if ... end можно использовать при инициализации переменных).

Условие true всегда истинно. Условие true и соответствующая ему последовательность операторов могут быть опущены - в этом случае оператор if ... end, проверив все условия и не найдя среди них верного, возбудит исключительную ситуацию, в случае необработки которой поток, выполнявший оператор if ... end, будет завершен.

Необходимо помнить, что перед ключевым словом end точка с запятой никогда не ставится.

\myparagraph{Функции}

Любая подпрограмма в Erlang'е суть есть функция - то есть любая подпрограмма в Erlang'е возвращает в вызывающую ее подпрограмму определенное значение определенного типа после определенных операций над своими параметрами.

Синтаксис описания функции приведен в листинге \ref{listing:erlang:fun}.

\mylistingbegin{erlang:fun}{Описание функции}
\begin{lstlisting}

function(PTRN_1) ->

	OP_1,
	...
	OP_N;

function(PTRN_2) when COND ->

	...;

...

function(PTRN_Q) ->

	...
	.

\end{lstlisting}
\mylistingend

В листинге \ref{listing:erlang:fun} содержится объявление функции с именем function. В Erlang'е допускается перегрузка функций - каждая функция в Erlang'е идентифицируется по имени и количеству параметров. Имена функций в Erlang'е подчиняются тем же требованиям, что и имена атомов.

Функция function() выполняет следущую последовательность действий:

\begin{enumerate}

	\item проверяет совпадение переданного ей набора фактических параметров с шаблоном PTRN\_1. Если шаблон и набор фактических параметров совпадают, то функция выполняет последовательность операторов OP, ..., OP\_N, возвращая значение последнего оператора (OP\_N) в вызывающую ее функцию;

	\item если набор фактических параметров не совпал с шаблоном \linebreak PTRN\_1, то Erlang проверяет совпадение набора фактических параметров со следующим шаблоном (PTRN\_2), при этом последовательность операторов, соответствующая данному шаблону, будет выполнена только в том случае, если набор фактических параметров совпадет с шаблоном PTRN\_2 и будет выполнено условие COND;

	\item проверка совпадения набора фактических параметров с шаблонами продолжается до тех пор, пока совпадение не будет найдено. Как только совпадение будет найдено - будет выполнена соответствующая последовательность операторов. Если же совпадения найти не удасться, то функция возбудит исключительную ситуацию, без должной обработки которой вычислительный поток, выполняющий функцию, завершит свое выполнение.

\end{enumerate}

Функция должна состоять как минимум из одного блока сопоставления набора своих параметров с шаблоном и соответствующей последовательности операторов.

В шаблонах допускается использовать имена переменных - в этом случае внутри функции переменной с именем, использованным в шаблоне, будет присвоено соответствующее значение из набора фактических параметров.

Элементы шаблона, соответствующие параметрам, должны быть перечислены через запятую.

Синтаксис вызова функции приведен в листинге \ref{listing:erlang:fun:call}.

\mylistingbegin{erlang:fun:call}{Вызов функции}
\begin{lstlisting}

function(PAR_1, PAR_2, ..., PAR_R).

\end{lstlisting}
\mylistingend

В листинге \ref{listing:erlang:fun:call} содержится вызов функции function() с набором фактических значений ее параметров - PAR\_1, PAR\_2, ..., PAR\_R.

\mysubparagraph{$\lambda$-выражения}

Каждая функция в Erlang'е суть есть переменная, тип данных которой - функция. Функции, таким образом, можно передавать как параметр в другие функции; возможно составление списков функций.

Одним из удобных способов описания функций в Erlang'е является использование ключевого слова fun. С помощью ключевого слова fun функцию можно описать непосредственно в инструкции инициализации некоторой переменной - таковое описание функций называют также $\lambda$-выражением.

Синтаксис $\lambda$-выражения приведен в листинге \ref{listing:erlang:lambda}.

\mylistingbegin{erlang:lambda}{$\lambda$-выражение}
\begin{lstlisting}

VARIABLE = fun(PAR_1, PAR_2, ..., PAR_N) -> EXPRESSION end.

\end{lstlisting}
\mylistingend

В листинге \ref{listing:erlang:lambda} переменной VARIABLE присваивается значение типа <<функция>>. Функция VARIABLE обладает параметрами \linebreak PAR\_1, PAR\_2, ..., PAR\_N и возвращает значение выражения EXPRESSION.

\myparagraph{Стандартная библиотека}

Erlang обладает обширной стандартной библиотекой функций.

Программист в разрабатываемом им программном модуле может вызвать функцию из стандартной библиотеки одним из следующих способов:

\begin{itemize}

	\item определив список функций, импортируемых из целевого модуля стандартной библиотеки, с помощью диррективы import, как это было сделано в листинге \ref{listing:erlang:simple-module};
	\item вызвать функцию с помощью оператора расширения пространства имен :~.

\end{itemize}

Описание стандартной библиотеки содержится в официальной документации \cite{erlang-doc}.

\mysubsubsection{Параллельное программирование с помощью языка программирования Erlang}

Erlang реализует модель параллельных вычислений с взаимодействием вычислительных потоков путем обмена сообщениями. Мы будем придерживаться терминологии официальной документации Erlang'а и называть вычислительные потоки процессами.

Процесс в Erlang'е может быть запущен с помощью функции spawn(), имеющей следующие параметры:

\begin{enumerate}

	\item строка с именем виртуальной машины, на которой необходимо запустить процесс, и IP-адресом вычислительного узла, на котором данная виртуальная машина запущена.

	Данный параметр может быть опущен, если требуется запустить процесс на виртуальной машине, исполняющей запускающий процесс;

	\item имя модуля, экспортирующего главную функцию запускаемого процесса;

	\item имя главной функции запускаемого процесса.

	Данная функция будет запущена сразу после создания нового процесса и процесс завершится по возврату из данной функции;

	\item список фактических значений параметров главной функции запускаемого процесса.

\end{enumerate}

Функция spawn() возвращает PID запущенного процесса. Процесс может получить свой PID, вызвав функцию self().

Оператор ! используется для отправления сообщения целевому процессу. Оператор ! является бинарным - его левый операнд суть есть PID процесса - получателя сообщения, правый операнд - отправляемое сообщение (значение произвольного типа).

Каждый процесс обладает очередью сообщений, сообщения из которой он может выбирать с помощью оператора receive ... end. Если очередь сообщений пуста, то оператор receive ... end заблокирует процесс до поступления туда сообщений, интересующих процесс.

Синтаксис оператора receive ... end приведен в листинге \ref{listing:erlang:receive}.

\mylistingbegin{erlang:receive}{Оператор receive ... end}
\begin{lstlisting}

receive

	PTRN_1 ->

		OP_1,
		...,
		OP_N;

	...

	true ->

		...

end.

\end{lstlisting}
\mylistingend

Поведение оператора receive ... end совпадает с поведением оператора if ... end с той лишь разницей, что оператор receive ... end последовательно сопоставляет с набром шаблонов каждое сообщение очереди сообщений процесса в порядке их поступления или блокирует процесс до поступления сообщения, которое бы удовлетворило хотя бы одному шаблону.

